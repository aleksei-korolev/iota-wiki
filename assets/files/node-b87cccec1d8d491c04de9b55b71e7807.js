const streams=require("../node/streams");async function main(){let e="https://chrysalis-nodes.iota.org/",o=new streams.SendOptions(e,!0);const n=await(new streams.ClientBuilder).node(e).build();let s=B(81),l=streams.Author.fromClient(streams.StreamsClient.fromClient(n),s,streams.ChannelType.SingleBranch);console.log("channel address: ",l.channel_address()),console.log("multi branching: ",l.is_multi_branching()),console.log("IOTA client info:",await n.getInfo());let t=await l.clone().send_announce(),c=t.link;console.log("announced at: ",c.toString()),console.log("Announce message index: "+c.toMsgIndexHex());let a=await l.clone().get_client().get_link_details(c);console.log("Announce message id: "+a.get_metadata().message_id);let r=B(81),i=new streams.Subscriber(r,o.clone());await i.clone().receive_announcement(c.copy());let g=i.author_public_key();console.log("Channel registered by subscriber, author's public key: ",g);let u=i.fetch_state();console.log("Subscribing..."),t=await i.clone().send_subscribe(c.copy());let d=t.link;console.log("Subscription message at: ",d.toString()),console.log("Subscription message index: "+d.toMsgIndexHex()),await l.clone().receive_subscribe(d.copy()),console.log("Subscription processed"),console.log("Sending Keyload"),t=await l.clone().send_keyload_for_everyone(c.copy());let m=t.link;console.log("Keyload message at: ",m.toString()),console.log("Keyload message index: "+m.toMsgIndexHex()),console.log("Subscriber syncing..."),await i.clone().syncState();let b=N("Public"),h=N("Masked");console.log("Subscriber Sending tagged packet"),t=await i.clone().send_tagged_packet(m,b,h);let p=t.link;console.log("Tag packet at: ",p.toString()),console.log("Tag packet index: "+p.toMsgIndexHex());let _=p;console.log("Subscriber Sending multiple signed packets");for(var y=0;y<10;y++)t=await i.clone().send_signed_packet(_,b,h),_=t.link,console.log("Signed packet at: ",_.toString()),console.log("Signed packet index: "+_.toMsgIndexHex());console.log("\nAuthor fetching next messages");for(const F of await l.clone().fetchNextMsgs())console.log("Found a message..."),console.log("Message type: ",F.messageType),console.log("Public: ",q(F.message.get_public_payload()),"\tMasked: ",q(F.message.get_masked_payload()));console.log("\nSub sending unsubscribe message"),t=await i.clone().send_unsubscribe(d),await l.clone().receive_unsubscribe(t.link),console.log("Author received unsubscribe and processed it"),console.log("\nAuthor sending new keyload to all subscribers"),t=await l.clone().send_keyload_for_everyone(c.copy()),await i.clone().receive_keyload(t.link)?console.log("unsubscription unsuccessful"):console.log("unsubscription successful"),console.log("\nSubscriber resetting state"),i.clone().reset_state();let S=i.fetch_state();for(var f=!0,k=0;k<S.length;k++)u[k].link.toString()==S[k].link.toString()&&u[k].seqNo==S[k].seqNo&&u[k].branchNo==S[k].branchNo||(f=!1);f?console.log("States match"):console.log("States do not match"),console.log("\nAuthor fetching prev messages");let w=await l.clone().fetch_prev_msgs(_,3);for(var x=0;x<w.length;x++)console.log("Found a message at ",w[x].link.toString()),console.log("Found a message at index: "+w[x].link.toMsgIndexHex());console.log("\nExporting and importing state");let v="password",A=l.clone().export(v),M=new streams.StreamsClient(e,o.clone()),C=streams.Author.import(M,A,v);C.channel_address!==l.channel_address?console.log("import failed"):console.log("import succesfull"),C.announcementLink()!=c.toString()?console.log("recovered announcement does not match"):console.log("recovered announcement matches"),console.log("\nRecovering without state import"),(await streams.Author.recover(s,c.copy(),streams.ChannelType.SingleBranch,o.clone())).channel_address!==l.channel_address?console.log("recovery failed"):console.log("recovery succesfull");let I=B(81),H=new streams.Subscriber(I,o.clone());await H.clone().receive_announcement(c.copy());let T=H.get_public_key();function N(e){for(var o=[],n=0;n<e.length;++n)o.push(e.charCodeAt(n));return o}function q(e){for(var o="",n=0;n<e.length;++n)o+=String.fromCharCode(e[n]);return o}function B(e){const o="abcdefghijklmnopqrstuvwxyz";let n="";for(k=9;k<e;k++)n+=o[Math.floor(Math.random()*o.length)];return n}l.clone().store_new_subscriber(T),console.log("\nAuthor manually subscribed sub 2"),l.clone().remove_subscriber(T),console.log("Author manually unsubscribed sub 2")}streams.set_panic_hook(),main().then((()=>{console.log("Done example")})).catch((e=>{console.log(e)}));