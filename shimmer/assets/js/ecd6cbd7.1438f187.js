"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[43646],{20389:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>d,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var t=i(87462),a=(i(67294),i(3905));var o=i(74434);const r={title:"Domain Linkage",sidebar_label:"Create and Verify",description:"Explain how to link a domain and a DID",image:"/img/Identity_icon.png",keywords:["well-known","domain linkage","DID Configuration Resource","Domain Linkage Credential"]},d="Domain Linkage",l={unversionedId:"concepts/domain_linkage/domain_linkage",id:"concepts/domain_linkage/domain_linkage",title:"Domain Linkage",description:"Explain how to link a domain and a DID",source:"@site/shimmer/external/identity.rs/0.7-alpha/documentation/docs/concepts/domain_linkage/domain_linkage.mdx",sourceDirName:"concepts/domain_linkage",slug:"/concepts/domain_linkage/",permalink:"/shimmer/identity.rs/concepts/domain_linkage/",draft:!1,editUrl:"https://github.com/iotaledger/identity.rs/edit/dev/documentation/shimmer/external/identity.rs/0.7-alpha/documentation/docs/concepts/domain_linkage/domain_linkage.mdx",tags:[],version:"current",frontMatter:{title:"Domain Linkage",sidebar_label:"Create and Verify",description:"Explain how to link a domain and a DID",image:"/img/Identity_icon.png",keywords:["well-known","domain linkage","DID Configuration Resource","Domain Linkage Credential"]},sidebar:"docs",previous:{title:"Verifiable Presentations",permalink:"/shimmer/identity.rs/concepts/verifiable_credentials/verifiable_presentations"},next:{title:"Overview",permalink:"/shimmer/identity.rs/libraries/overview"}},s={},c=[{value:"Overview",id:"overview",level:2},{value:"DID Configuration Resource",id:"did-configuration-resource",level:3},{value:"Linked Domain Service Endpoint",id:"linked-domain-service-endpoint",level:3},{value:"Verifying DID and Domain Linkage",id:"verifying-did-and-domain-linkage",level:3},{value:"Example",id:"example",level:3}],u={toc:c};function m(e){let{components:n,...r}=e;return(0,a.kt)("wrapper",(0,t.Z)({},u,r,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"domain-linkage"},"Domain Linkage"),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"Domain Linkage can provide proof for a connection between a DID and a domain being controlled by the same entity. This linkage can transfer trust from a domain to a DID and vice verca. For instance, if an entity trusts a domain, it can also trust the linked DID and all documents signed by verification methods included in the DID Document. A use case coud be a verifier that trusts ",(0,a.kt)("inlineCode",{parentName:"p"},"www.example.com")," and receives a Verifiable Presentation issued by ",(0,a.kt)("inlineCode",{parentName:"p"},"did:foo:abc"),". By ",(0,a.kt)("inlineCode",{parentName:"p"},"did:foo:abc")," being linked to ",(0,a.kt)("inlineCode",{parentName:"p"},"www.example.com"),", the verifier can trust that the Verifiable Presentation is issued by the same entity controlling ",(0,a.kt)("inlineCode",{parentName:"p"},"www.example.com"),".\nThe DIF has approved a ",(0,a.kt)("a",{parentName:"p",href:"https://identity.foundation/.well-known/resources/did-configuration/"},"Well Known DID Configuration")," draft to standardize this connection by introducing the ",(0,a.kt)("a",{parentName:"p",href:"https://identity.foundation/.well-known/resources/did-configuration/#did-configuration-resource"},"DID Configuration Resource")," and the ",(0,a.kt)("a",{parentName:"p",href:"https://identity.foundation/.well-known/resources/did-configuration/#linked-domain-service-endpoint"},"Linked Domain Service Endpoint"),"."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Identity getting started",src:i(17022).Z,width:"2042",height:"831"})),(0,a.kt)("h3",{id:"did-configuration-resource"},"DID Configuration Resource"),(0,a.kt)("p",null,"Suppose that a DID ",(0,a.kt)("inlineCode",{parentName:"p"},"did:foo:example")," with the following DID Document only containing a ",(0,a.kt)("inlineCode",{parentName:"p"},"verificationMethod")," ",(0,a.kt)("inlineCode",{parentName:"p"},"key-1")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "id": "did:foo:abc",\n    "verificationMethod": [\n      {\n        "id": "did:foo:abc#key-1",\n        "controller": "did:foo:abc",\n        "type": "Ed25519VerificationKey2018",\n        "publicKeyMultibase": "zDShpHKXkcHKHcF8CnGAA1UqyyuEPRNz1XFEuggbWJQSq"\n      }\n    ]\n  },\n')),(0,a.kt)("p",null,"and the domain ",(0,a.kt)("inlineCode",{parentName:"p"},"https://www.example.com")," represents the same entity and need be linked to increase trust in the DID."),(0,a.kt)("p",null,"To establish this linkage, A ",(0,a.kt)("a",{parentName:"p",href:"https://identity.foundation/.well-known/resources/did-configuration/#did-configuration-resource"},"DID Configuration Resource")," must be created and made available on the ",(0,a.kt)("a",{parentName:"p",href:"https://identity.foundation/.well-known/resources/did-configuration/#did-configuration-uri"},"DID Configuration URL"),". In this case it's ",(0,a.kt)("inlineCode",{parentName:"p"},"https://example.com/.well-known/did-configuration.json"),"."),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://identity.foundation/.well-known/resources/did-configuration/#did-configuration-resource"},"DID Configuration Resource")," is a JSON-LD object containing verifiable credentials called ",(0,a.kt)("inlineCode",{parentName:"p"},"Domain Linkage Credentials"),". Each credential represents a linkage to a single DID."),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Note that one ",(0,a.kt)("inlineCode",{parentName:"p"},"DID Configuration Resource")," can include multiple ",(0,a.kt)("inlineCode",{parentName:"p"},"Domain Linkage Credentials")," effectivaly linking the same domain to multiple DIDs.")),(0,a.kt)("p",null,"In this example, the domain ",(0,a.kt)("inlineCode",{parentName:"p"},"https://www.example.com")," needs to be linked to the DID ",(0,a.kt)("inlineCode",{parentName:"p"},"did:foo:abc"),". This means that the ",(0,a.kt)("inlineCode",{parentName:"p"},"DID Configuration Resource")," will have one ",(0,a.kt)("inlineCode",{parentName:"p"},"Domain Linkage Credential"),". This credential must have the following properties:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Its ",(0,a.kt)("inlineCode",{parentName:"li"},"type")," includes ",(0,a.kt)("inlineCode",{parentName:"li"},"DomainLinkageCredential"),". "),(0,a.kt)("li",{parentName:"ul"},"It includes the DID Configuration context."),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"credentialSubject")," must be the DID ",(0,a.kt)("inlineCode",{parentName:"li"},"did:foo:abc")," and references the domain ",(0,a.kt)("inlineCode",{parentName:"li"},"https://www.example.com"),"."),(0,a.kt)("li",{parentName:"ul"},"The issuer is the DID itself ",(0,a.kt)("inlineCode",{parentName:"li"},"did:foo:abc"),"."),(0,a.kt)("li",{parentName:"ul"},"It is signed by a key material included in the DID Document, in this case ",(0,a.kt)("inlineCode",{parentName:"li"},"did:foo:abc#key-1"),".")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "@context": "https://identity.foundation/.well-known/did-configuration/v1",\n  "linked_dids": [\n    {\n      "@context": [\n        "https://www.w3.org/2018/credentials/v1",\n        "https://identity.foundation/.well-known/did-configuration/v1"\n      ],\n      "type": [\n        "VerifiableCredential",\n        "DomainLinkageCredential"\n      ],\n      "credentialSubject": {\n        "id": "did:foo:abc",\n        "origin": "https://www.example.com/"\n      },\n      "issuer": "did:foo:abc",\n      "issuanceDate": "2023-02-09T22:14:15Z",\n      "expirationDate": "2024-02-09T22:14:15Z",\n      "proof": {\n        "type": "JcsEd25519Signature2020",\n        "verificationMethod": "did:foo:abc#key-1",\n        "signatureValue": "4SvYqo3YoArfW7r7qKfN7RUJdZnBteb166KE4UkX8MNdbp5UW6YbykneAzvjyRmf5EVQ9bnP9cS5sbEPUn2uaAcB"\n      }\n    }\n  ]\n}\n\n')),(0,a.kt)("p",null,"Now this ",(0,a.kt)("inlineCode",{parentName:"p"},"DID Configuration Resource")," must be made available on ",(0,a.kt)("inlineCode",{parentName:"p"},"https://example.com/.well-known/did-configuration.json")," which establishes the  linkage.  "),(0,a.kt)("h3",{id:"linked-domain-service-endpoint"},"Linked Domain Service Endpoint"),(0,a.kt)("p",null,"By having a domain, one can discover what DIDs are linked to it by fetching the ",(0,a.kt)("inlineCode",{parentName:"p"},"DID Configuration Resource")," and investigating the ",(0,a.kt)("inlineCode",{parentName:"p"},"Domain Linkage Credentials"),". To enable discovery from the other direction, when having a DID and wanting to discover which domains are linked to it, a ",(0,a.kt)("a",{parentName:"p",href:"https://identity.foundation/.well-known/resources/did-configuration/#linked-domain-service-endpoint"},"Linked Domain Service Endpoint")," can be added to the DID Document. The DID Document from this example will be extended as follows to enable discovery of ",(0,a.kt)("inlineCode",{parentName:"p"},"https://www.example.com"),": "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "id": "did:foo:abc",\n    "verificationMethod": [\n      {\n        "id": "did:foo:abc#key-1",\n        "controller": "did:foo:abc",\n        "type": "Ed25519VerificationKey2018",\n        "publicKeyMultibase": "zDShpHKXkcHKHcF8CnGAA1UqyyuEPRNz1XFEuggbWJQSq"\n      }\n    ],\n    "service": [\n      {\n        "id": "did:foo:abc#domain-linkage",\n        "type": "LinkedDomains",\n        "serviceEndpoint": "https://www.example.com/"\n      }\n    ]\n  }\n')),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Note that a DID Document can have multiple ",(0,a.kt)("inlineCode",{parentName:"p"},"Linked Domain Services")," and each service can link to multiple domains.")),(0,a.kt)("h3",{id:"verifying-did-and-domain-linkage"},"Verifying DID and Domain Linkage"),(0,a.kt)("p",null,"As mentioned above, the discovery of the Domain Linkage can happen from either direction. But verifying the linkage in both cases involves only verifying the DID Configuration Resource. The process is as follows:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Fetch ",(0,a.kt)("inlineCode",{parentName:"li"},"DID Configuration Resource")," from ",(0,a.kt)("inlineCode",{parentName:"li"},"https://www.example.com/.well-known/did-configuration.json"),"."),(0,a.kt)("li",{parentName:"ol"},"Resolve the DID Document of ",(0,a.kt)("inlineCode",{parentName:"li"},"did:foo:abc"),"."),(0,a.kt)("li",{parentName:"ol"},"Verify the ",(0,a.kt)("inlineCode",{parentName:"li"},"DID Configuration Resource")," and its ",(0,a.kt)("inlineCode",{parentName:"li"},"Domain Linkage Credential")," that references ",(0,a.kt)("inlineCode",{parentName:"li"},"did:foo:abc"),".")),(0,a.kt)("p",null,"Here you can learn more about  ",(0,a.kt)("a",{parentName:"p",href:"https://identity.foundation/.well-known/resources/did-configuration/#did-configuration-resource-verification"},"DID Configuration Resource Verification"),"."),(0,a.kt)("h3",{id:"example"},"Example"),(0,a.kt)(o.Z,{nodeContent:'// Copyright 2020-2023 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Client, MnemonicSecretManager } from "@iota/client-wasm/node";\nimport { Bip39 } from "@iota/crypto.js";\nimport {\n    Credential,\n    CredentialValidationOptions,\n    DIDUrl,\n    DomainLinkageConfiguration,\n    DomainLinkageValidator,\n    Duration,\n    IotaDID,\n    IotaDocument,\n    IotaIdentityClient,\n    LinkedDomainService,\n    ProofOptions,\n    Timestamp,\n} from "@iota/identity-wasm/node";\nimport { IAliasOutput, IRent, TransactionHelper } from "@iota/iota.js";\nimport { API_ENDPOINT, createDid } from "../util";\n\n/**\n * Demonstrates how to link a domain and a DID and verify the linkage.\n */\nexport async function domainLinkage() {\n    const client = new Client({\n        primaryNode: API_ENDPOINT,\n        localPow: true,\n    });\n    const didClient = new IotaIdentityClient(client);\n\n    // Generate a random mnemonic for our wallet.\n    const secretManager: MnemonicSecretManager = {\n        mnemonic: Bip39.randomMnemonic(),\n    };\n\n    // Creates a new wallet and identity (see "0_create_did" example).\n    let { document, keypair } = await createDid(client, secretManager);\n    const did: IotaDID = document.id();\n\n    // =====================================================\n    // Create Linked Domain service\n    // ====================================================\n\n    let domainFoo = "https://foo.example.com";\n    let domainBar = "https://bar.example.com";\n\n    // Create a Linked Domain Service to enable the discovery of the linked domains through the DID Document.\n    // This is optional since it is not a hard requirement by the spec.\n    let serviceUrl: DIDUrl = did.clone().join("#domain_linkage");\n    let linkedDomainService: LinkedDomainService = new LinkedDomainService({\n        id: serviceUrl,\n        domains: [domainFoo, domainBar],\n    });\n    document.insertService(linkedDomainService.toService());\n    let updatedDidDocument = await publishDocument(didClient, secretManager, document);\n    console.log("Updated DID document:", JSON.stringify(updatedDidDocument, null, 2));\n\n    // =====================================================\n    // Create DID Configuration resource\n    // =====================================================\n\n    // Now the DID Document contains a service that includes the domains.\n    // To allow a bidirectional linkage, the domains must link to the DID. This is\n    // done by creating a `DID Configuration Resource` that includes a `Domain Linkage Credential`\n    // and can be made available on the domain.\n\n    // Create the Domain Linkage Credential.\n    let domainLinkageCredential: Credential = Credential.createDomainLinkageCredential({\n        issuer: document.id(),\n        origin: domainFoo,\n        expirationDate: Timestamp.nowUTC().checkedAdd(Duration.weeks(10))!,\n    });\n\n    // Sign the credential.\n    domainLinkageCredential = document.signCredential(\n        domainLinkageCredential,\n        keypair.private(),\n        "#key-1",\n        ProofOptions.default(),\n    );\n\n    // Create the DID Configuration Resource which wraps the Domain Linkage credential.\n    let configurationResource: DomainLinkageConfiguration = new DomainLinkageConfiguration([domainLinkageCredential]);\n\n    // The DID Configuration resource can be made available on `https://foo.example.com/.well-known/did-configuration.json`.\n    let configurationResourceJson = configurationResource.toJSON();\n    console.log("Configuration Resource:", JSON.stringify(configurationResource.toJSON(), null, 2));\n\n    // Now the DID Document links to the Domains through the service, and the Foo domain links to the DID\n    // through the DID Configuration resource. A bidirectional linkage is established.\n    // Note however that bidirectionality is not a hard requirement. It is valid to have a Domain Linkage\n    // credential point to a DID, without the DID having a service that points back.\n\n    // =====================================================\n    // Verification can start from two different places.\n    // The first case answers the question "What DID is this domain linked to?"\n    // while the second answers "What domain is this DID linked to?".\n    // ====================================================\n\n    // =====================================================\n    // \u2192 Case 1: starting from domain\n    // =====================================================\n\n    // Fetch the DID Configuration resource (For example using the Fetch API).\n    // Note that according to the specs, the DID Configuration resource must exist\n    // at the origin\'s root, well-known Resource directory.\n    const _configurationUrl = `${domainFoo}/.well-known/did-configuration.json")`;\n\n    // But since the DID Configuration\n    // resource isn\'t available online in this example, we will simply use the JSON.\n    let fetchedConfigurationResource = DomainLinkageConfiguration.fromJSON(configurationResource);\n\n    // Retrieve the issuers of the Domain Linkage Credentials which correspond to the possibly linked DIDs.\n    // Note that in this example only the first entry in the credential is validated.\n    let issuers: Array<string> = fetchedConfigurationResource.issuers();\n    const issuerDocument: IotaDocument = await didClient.resolveDid(IotaDID.parse(issuers[0]));\n\n    // Validate the linkage between the Domain Linkage Credential in the configuration and the provided issuer DID.\n    // Validation succeeds when no error is thrown.\n    DomainLinkageValidator.validateLinkage(\n        issuerDocument,\n        fetchedConfigurationResource,\n        domainFoo,\n        CredentialValidationOptions.default(),\n    );\n\n    // =====================================================\n    // \u2192 Case 2: starting from a DID\n    // =====================================================\n\n    const didDocument: IotaDocument = await didClient.resolveDid(did);\n\n    // Get the Linked Domain Services from the DID Document.\n    let linkedDomainServices: LinkedDomainService[] = didDocument\n        .service()\n        .filter(service => LinkedDomainService.isValid(service))\n        .map(service => LinkedDomainService.fromService(service));\n\n    // Get the domains included in the Linked Domain Service.\n    // Note that in this example only the first entry in the service is validated.\n    let domains: string[] = linkedDomainServices[0].domains();\n\n    // Fetch the DID Configuration resource (For example using the Fetch API).\n    // Note that according to the specs, the DID Configuration resource must exist\n    // at the origin\'s root, Well-Known Resource directory.\n    const __configurationUrl = `${domains[0]}/.well-known/did-configuration.json")`;\n\n    // But since the DID Configuration\n    // resource isn\'t available online in this example, we will simply use the JSON.\n    fetchedConfigurationResource = DomainLinkageConfiguration.fromJSON(configurationResource);\n\n    // Validate the linkage between the Domain Linkage Credential in the configuration and the provided issuer DID.\n    // Validation succeeds when no error is thrown.\n    DomainLinkageValidator.validateLinkage(\n        didDocument,\n        fetchedConfigurationResource,\n        domains[0],\n        CredentialValidationOptions.default(),\n    );\n}\n\nasync function publishDocument(\n    client: IotaIdentityClient,\n    secretManager: MnemonicSecretManager,\n    document: IotaDocument,\n): Promise<IotaDocument> {\n    // Resolve the latest output and update it with the given document.\n    const aliasOutput: IAliasOutput = await client.updateDidOutput(document);\n\n    // Because the size of the DID document increased, we have to increase the allocated storage deposit.\n    // This increases the deposit amount to the new minimum.\n    const rentStructure: IRent = await client.getRentStructure();\n    aliasOutput.amount = TransactionHelper.getStorageDeposit(aliasOutput, rentStructure).toString();\n\n    // Publish the output.\n    const updated: IotaDocument = await client.publishDidOutput(secretManager, aliasOutput);\n    return updated;\n}\n',rustContent:'// Copyright 2020-2023 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nuse examples::create_did;\nuse examples::random_stronghold_path;\nuse examples::API_ENDPOINT;\nuse identity_iota::core::Duration;\nuse identity_iota::core::FromJson;\nuse identity_iota::core::Object;\nuse identity_iota::core::OrderedSet;\nuse identity_iota::core::Timestamp;\nuse identity_iota::core::ToJson;\nuse identity_iota::core::Url;\nuse identity_iota::credential::Credential;\nuse identity_iota::credential::CredentialValidationOptions;\nuse identity_iota::credential::DomainLinkageConfiguration;\nuse identity_iota::credential::DomainLinkageCredentialBuilder;\nuse identity_iota::credential::DomainLinkageValidationError;\nuse identity_iota::credential::DomainLinkageValidator;\nuse identity_iota::credential::Issuer;\nuse identity_iota::credential::LinkedDomainService;\nuse identity_iota::crypto::KeyPair;\nuse identity_iota::crypto::ProofOptions;\nuse identity_iota::did::DIDUrl;\nuse identity_iota::did::DID;\nuse identity_iota::iota::IotaClientExt;\nuse identity_iota::iota::IotaDID;\nuse identity_iota::iota::IotaDocument;\nuse identity_iota::iota::IotaIdentityClientExt;\nuse identity_iota::resolver::Resolver;\nuse iota_client::block::address::Address;\nuse iota_client::block::output::AliasOutput;\nuse iota_client::block::output::AliasOutputBuilder;\nuse iota_client::block::output::RentStructure;\nuse iota_client::secret::stronghold::StrongholdSecretManager;\nuse iota_client::secret::SecretManager;\nuse iota_client::Client;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n  // Create a new client to interact with the IOTA ledger.\n  let client: Client = Client::builder().with_primary_node(API_ENDPOINT, None)?.finish()?;\n\n  // Create a new secret manager backed by a Stronghold.\n  let mut secret_manager: SecretManager = SecretManager::Stronghold(\n    StrongholdSecretManager::builder()\n      .password("secure_password")\n      .build(random_stronghold_path())?,\n  );\n\n  // Create a DID for the entity that will issue the Domain Linkage Credential.\n  let (_, mut did_document, keypair): (Address, IotaDocument, KeyPair) =\n    create_did(&client, &mut secret_manager).await?;\n  let did: IotaDID = did_document.id().clone();\n\n  // =====================================================\n  // Create Linked Domain service\n  // =====================================================\n\n  // The DID should be linked to the following domains.\n  let domain_1: Url = Url::parse("https://foo.example.com")?;\n  let domain_2: Url = Url::parse("https://bar.example.com")?;\n\n  let mut domains: OrderedSet<Url> = OrderedSet::new();\n  domains.append(domain_1.clone());\n  domains.append(domain_2.clone());\n\n  // Create a Linked Domain Service to enable the discovery of the linked domains through the DID Document.\n  // This is optional since it is not a hard requirement by the specs.\n  let service_url: DIDUrl = did.clone().join("#domain-linkage")?;\n  let linked_domain_service: LinkedDomainService =\n    LinkedDomainService::new(service_url, domains, Object::new()).unwrap();\n  did_document.insert_service(linked_domain_service.into())?;\n  let updated_did_document: IotaDocument = publish_document(client.clone(), secret_manager, did_document).await?;\n\n  println!("DID document with linked domain service: {updated_did_document:#}");\n\n  // =====================================================\n  // Create DID Configuration resource\n  // =====================================================\n\n  // Now the DID Document contains a service that includes the domains.\n  // To allow a bidirectional linkage, the domains must link to the DID. This is\n  // done by creating a `DID Configuration Resource` that includes a `Domain Linkage Credential`\n  // and can be made available on the domain.\n\n  // Create the Domain Linkage Credential.\n  let mut domain_linkage_credential: Credential = DomainLinkageCredentialBuilder::new()\n    .issuer(Issuer::Url(updated_did_document.id().to_url().into()))\n    .origin(domain_1.clone())\n    .issuance_date(Timestamp::now_utc())\n    // Expires after a year.\n    .expiration_date(Timestamp::now_utc().checked_add(Duration::days(365)).unwrap())\n    .build()?;\n\n  // Sign the credential.\n  updated_did_document.sign_data(\n    &mut domain_linkage_credential,\n    keypair.private(),\n    "#key-1",\n    ProofOptions::default(),\n  )?;\n\n  // Create the DID Configuration Resource which wraps the Domain Linkage credential.\n  let configuration_resource: DomainLinkageConfiguration =\n    DomainLinkageConfiguration::new(vec![domain_linkage_credential]);\n  println!("Configuration Resource >>: {configuration_resource:#}");\n\n  // The DID Configuration resource can be made available on `https://foo.example.com/.well-known/did-configuration.json`.\n  let configuration_resource_json: String = configuration_resource.to_json()?;\n\n  // Now the DID Document links to the Domains through the service, and the Foo domain links to the DID\n  // through the DID Configuration resource. A bidirectional linkage is established.\n  // Note however that bidirectionality is not a hard requirement. It is valid to have a Domain Linkage\n  // credential point to a DID, without the DID having a service that points back.\n\n  // =====================================================\n  // Verification can start from two different places.\n  // The first case answers the question "What DID is this domain linked to?"\n  // while the second answers "What domain is this DID linked to?".\n  // =====================================================\n\n  // Init a resolver for resolving DID Documents.\n  let mut resolver: Resolver<IotaDocument> = Resolver::new();\n  resolver.attach_iota_handler(client.clone());\n\n  // =====================================================\n  // \u2192 Case 1: starting from domain\n  // =====================================================\n  let domain_foo: Url = domain_1.clone();\n\n  // Fetch the DID Configuration resource\n  // let configuration_resource: DomainLinkageConfiguration =\n  // DomainLinkageConfiguration::fetch_configuration(domain_foo).await.unwrap();\n\n  // But since the DID Configuration\n  // resource isn\'t available online in this example, we will simply deserialize the JSON.\n  let configuration_resource: DomainLinkageConfiguration =\n    DomainLinkageConfiguration::from_json(&configuration_resource_json)?;\n\n  // Retrieve the issuers of the Domain Linkage Credentials which correspond to the possibly linked DIDs.\n  let linked_dids: Vec<&Url> = configuration_resource.issuers().collect();\n  assert_eq!(linked_dids.len(), 1);\n\n  // Resolve the DID Document of the DID that issued the credential.\n  let issuer_did_document: IotaDocument = resolver.resolve(&did).await.unwrap();\n\n  // Validate the linkage between the Domain Linkage Credential in the configuration and the provided issuer DID.\n  let validation_result: Result<(), DomainLinkageValidationError> = DomainLinkageValidator::validate_linkage(\n    &issuer_did_document,\n    &configuration_resource,\n    &domain_foo,\n    &CredentialValidationOptions::default(),\n  );\n  assert!(validation_result.is_ok());\n\n  // =====================================================\n  // \u2192 Case 2: starting from a DID\n  // =====================================================\n  let did_document: IotaDocument = resolver.resolve(&did).await.unwrap();\n\n  // Get the Linked Domain Services from the DID Document.\n  let linked_domain_services: Vec<LinkedDomainService> = did_document\n    .service()\n    .iter()\n    .cloned()\n    .filter_map(|service| LinkedDomainService::try_from(service).ok())\n    .collect();\n  assert_eq!(linked_domain_services.len(), 1);\n\n  // Get the domains included in the Linked Domain Service.\n  let domains: &[Url] = linked_domain_services.get(0).unwrap().domains();\n\n  let domain_foo: Url = domains.get(0).unwrap().clone();\n  assert_eq!(domain_foo, domain_1);\n\n  // Fetch the DID Configuration resource\n  // let configuration_resource: DomainLinkageConfiguration =\n  // DomainLinkageConfiguration::fetch_configuration(domain_foo).await.unwrap();\n\n  // But since the DID Configuration\n  // resource isn\'t available online in this example, we will simply deserialize the JSON.\n  let configuration_resource: DomainLinkageConfiguration =\n    DomainLinkageConfiguration::from_json(&configuration_resource_json)?;\n\n  // Validate the linkage.\n  let validation_result: Result<(), DomainLinkageValidationError> = DomainLinkageValidator::validate_linkage(\n    &did_document,\n    &configuration_resource,\n    &domain_foo,\n    &CredentialValidationOptions::default(),\n  );\n  assert!(validation_result.is_ok());\n  Ok(())\n}\n\nasync fn publish_document(\n  client: Client,\n  secret_manager: SecretManager,\n  document: IotaDocument,\n) -> anyhow::Result<IotaDocument> {\n  // Resolve the latest output and update it with the given document.\n  let alias_output: AliasOutput = client.update_did_output(document.clone()).await?;\n\n  // Because the size of the DID document increased, we have to increase the allocated storage deposit.\n  // This increases the deposit amount to the new minimum.\n  let rent_structure: RentStructure = client.get_rent_structure().await?;\n  let alias_output: AliasOutput = AliasOutputBuilder::from(&alias_output)\n    .with_minimum_storage_deposit(rent_structure)\n    .finish(client.get_token_supply().await?)?;\n\n  // Publish the updated Alias Output.\n  Ok(client.publish_did_output(&secret_manager, alias_output).await.unwrap())\n}\n',nodeGithubLink:"https://github.com/iotaledger/identity.rs/blob/main/bindings/wasm/examples/src/1_advanced/6_domain_linkage.ts",rustGithubLink:"https://github.com/iotaledger/identity.rs/blob/main/examples/1_advanced/7_domain_linkage.rs",mdxType:"CodeSnippet"}))}m.isMDXComponent=!0},74434:(e,n,i)=>{i.d(n,{Z:()=>r});var t=i(86010),a=i(67294),o=i(69319);function r(e){let{nodeReplitLink:n,nodeContent:i,rustContent:r,nodeGithubLink:d,rustGithubLink:l}=e;const[s,c]=a.useState("node"),u=a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"12",fill:"currentColor",class:"bi bi-box-arrow-up-right",viewBox:"0 0 16 16"},a.createElement("path",{"fill-rule":"evenodd",d:"M8.636 3.5a.5.5 0 0 0-.5-.5H1.5A1.5 1.5 0 0 0 0 4.5v10A1.5 1.5 0 0 0 1.5 16h10a1.5 1.5 0 0 0 1.5-1.5V7.864a.5.5 0 0 0-1 0V14.5a.5.5 0 0 1-.5.5h-10a.5.5 0 0 1-.5-.5v-10a.5.5 0 0 1 .5-.5h6.636a.5.5 0 0 0 .5-.5z"}),a.createElement("path",{"fill-rule":"evenodd",d:"M16 .5a.5.5 0 0 0-.5-.5h-5a.5.5 0 0 0 0 1h3.793L6.146 9.146a.5.5 0 1 0 .708.708L15 1.707V5.5a.5.5 0 0 0 1 0v-5z"}));return(0,a.useEffect)((()=>{let e=localStorage.getItem("lang"),t=e||"node";"node"!==t||n||i||(t="rust"),"rust"!==t||r||(t="node"),c(t)})),a.createElement("div",null,a.createElement("div",{className:(0,t.Z)("langSelector")},r&&a.createElement("button",{className:(0,t.Z)("button","languageButton",{activeButton:"rust"==s,inactiveButton:"rust"!==s}),onClick:()=>{localStorage.setItem("lang","rust"),c("rust")}},"Rust"),(n||i)&&a.createElement("button",{className:(0,t.Z)("button","languageButton","mr-sm",{activeButton:"node"===s,inactiveButton:"node"!==s}),onClick:()=>{localStorage.setItem("lang","node"),c("node")}},"Node.js")),a.createElement("div",{className:(0,t.Z)("codeSnippetContainer")},"node"===s&&n?a.createElement(a.Fragment,null,a.createElement("iframe",{frameborder:"0",width:"100%",height:"700px",src:n})):"node"===s&&i?a.createElement("div",{className:(0,t.Z)("nodeContainer")},a.createElement(o.Z,{className:(0,t.Z)("noMarginBottom"),language:"typescript"},i)):a.createElement("div",{className:(0,t.Z)("rustContainer")},a.createElement(o.Z,{className:(0,t.Z)("noMarginBottom"),language:"rust"},r))),a.createElement("div",{className:(0,t.Z)("githubLink")},d&&"node"===s&&a.createElement("a",{href:d,target:"_blank"},"GitHub\xa0",u),l&&"rust"===s&&a.createElement("a",{href:l,target:"_blank"},"GitHub\xa0",u)))}},17022:(e,n,i)=>{i.d(n,{Z:()=>t});const t=i.p+"assets/images/domain-linkage-diagram-67da2922ef4ff138c66ddf5c6adeeb3e.png"}}]);