"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[93271],{3905:(t,e,n)=>{n.d(e,{Zo:()=>l,kt:()=>h});var a=n(67294);function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function r(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach((function(e){o(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function s(t,e){if(null==t)return{};var n,a,o=function(t,e){if(null==t)return{};var n,a,o={},i=Object.keys(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||(o[n]=t[n]);return o}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(o[n]=t[n])}return o}var u=a.createContext({}),c=function(t){var e=a.useContext(u),n=e;return t&&(n="function"==typeof t?t(e):r(r({},e),t)),n},l=function(t){var e=c(t.components);return a.createElement(u.Provider,{value:e},t.children)},p={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},d=a.forwardRef((function(t,e){var n=t.components,o=t.mdxType,i=t.originalType,u=t.parentName,l=s(t,["components","mdxType","originalType","parentName"]),d=c(n),h=o,m=d["".concat(u,".").concat(h)]||d[h]||p[h]||i;return n?a.createElement(m,r(r({ref:e},l),{},{components:n})):a.createElement(m,r({ref:e},l))}));function h(t,e){var n=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var i=n.length,r=new Array(i);r[0]=d;var s={};for(var u in e)hasOwnProperty.call(e,u)&&(s[u]=e[u]);s.originalType=t,s.mdxType="string"==typeof t?t:o,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},29451:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>u,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(87462),o=(n(67294),n(3905));const i={description:"Mint a new NFT with iota.js.",image:"/img/client_banner.png",keywords:["tutorial","NFT","token","asset","digital","non","fungible","output","mint"]},r="Mint a New NFT",s={unversionedId:"tutorials/nft-transactions/mint-new-nft",id:"tutorials/nft-transactions/mint-new-nft",title:"Mint a New NFT",description:"Mint a new NFT with iota.js.",source:"@site/shimmer/external/iota.js/documentation/docs/tutorials/nft-transactions/03-mint-new-nft.md",sourceDirName:"tutorials/nft-transactions",slug:"/tutorials/nft-transactions/mint-new-nft",permalink:"/shimmer/iotajs/tutorials/nft-transactions/mint-new-nft",draft:!1,editUrl:"https://github.com/iotaledger/iota.js/tree/dev/packages/iota/documentation/shimmer/external/iota.js/documentation/docs/tutorials/nft-transactions/03-mint-new-nft.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{description:"Mint a new NFT with iota.js.",image:"/img/client_banner.png",keywords:["tutorial","NFT","token","asset","digital","non","fungible","output","mint"]},sidebar:"docs",previous:{title:"Prepare Your Development Environment",permalink:"/shimmer/iotajs/tutorials/nft-transactions/prepare-the-dev-env"},next:{title:"Create an NFT Transaction",permalink:"/shimmer/iotajs/tutorials/nft-transactions/nft-transaction"}},u={},c=[{value:"Define the NFT Output",id:"define-the-nft-output",level:2},{value:"Initialize the NFT",id:"initialize-the-nft",level:2},{value:"Unlock Conditions",id:"unlock-conditions",level:3},{value:"Define the Transaction Essence",id:"define-the-transaction-essence",level:2},{value:"Issue the Transaction",id:"issue-the-transaction",level:2},{value:"Calculate the NFT ID",id:"calculate-the-nft-id",level:2},{value:"Putting It All Together",id:"putting-it-all-together",level:2}],l={toc:c};function p(t){let{components:e,...n}=t;return(0,o.kt)("wrapper",(0,a.Z)({},l,n,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"mint-a-new-nft"},"Mint a New NFT"),(0,o.kt)("p",null,"An ",(0,o.kt)("a",{parentName:"p",href:"https://wiki.iota.org/shimmer/introduction/explanations/ledger/nft/"},"NFT")," is a unique token on the ledger. Its owner\ncontrols it through the private key of\nan ",(0,o.kt)("a",{parentName:"p",href:"https://wiki.iota.org/iota.rs/explanations/address_key_space/"},"address"),". An NFT has a unique ID assigned by the\nLedger, bound to an Output in the Ledger. An NFT has some immutable\nfeatures that cannot be changed through the lifetime of the NFT, namely the issuer of the NFT. Additionally, immutable\nmetadata links the NFT with a Digital Asset (image, video, etc.). The owner of the NFT can only change non-immutable\naspects of\nthe NFT by unlocking its unspent Output in a transaction and generating a\nnew Output (conserving the NFT ID). The owner can also use a transaction to transfer the NFT to another owner. As with\nother types of Outputs, NFT Outputs must also cover\ntheir ",(0,o.kt)("a",{parentName:"p",href:"https://wiki.iota.org/shimmer/introduction/explanations/what_is_stardust/storage_deposit/"},"storage costs")," with\nprotocol-defined tokens (",(0,o.kt)("inlineCode",{parentName:"p"},"SMR"),")."),(0,o.kt)("p",null,"To mint an NFT, you will need the following:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"A unspent ",(0,o.kt)("a",{parentName:"p",href:"https://wiki.iota.org/shimmer/tips/tips/TIP-0018/#basic-output"},"Basic Output")," that holds enough funds for\nthe minimal storage deposit needed for the NFT Output. In\nthe ",(0,o.kt)("a",{parentName:"p",href:"https://wiki.iota.org/shimmer/introduction/reference/networks/betanet/"},"Testnet"),", you\ncan ",(0,o.kt)("a",{parentName:"p",href:"https://wiki.iota.org/shimmer/iotajs/tutorials/value-transactions/request-funds-from-the-faucet/"},"request funds from the Faucet"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The key pair that corresponds to the Shimmer address that owns the former Output, as you need to unlock a certain\namount of funds to cover the storage deposit of the Output corresponding to the newly minted NFT.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The immutable metadata that will allow you to associate the NFT with a digital asset. For instance, you could store a\ndigital asset in a permissioned server. Upon proving ownership of the NFT, the server would grant access to the\nassociated digital asset. Remember the longer the metadata, the higher the storage deposit."))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'const consumedOutputId = "0xcb16...";\n\nconst sourceAddress = "0x62c0...";\n\nconst sourceAddressPublicKey = "0x91db...";\nconst sourceAddressPrivateKey = "0x22f...";\n\nconst client = new SingleNodeClient(API_ENDPOINT, {powProvider: new NeonPowProvider()});\nconst info = await client.info();\n')),(0,o.kt)("h2",{id:"define-the-nft-output"},"Define the NFT Output"),(0,o.kt)("p",null,"The initial NFT Output needed to mint your NFT can be defined as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'const initialNftId = new Uint8Array(new ArrayBuffer(32));\n\nconst immutableData = {\n    standard: "IRC27",\n    version: "v1.0",\n    type: "image/jpeg",\n    uri: "https://nft-oceean.example.org/my-nft.jpeg"\n};\n\nconst nftOutput: INftOutput = {\n    type: NFT_OUTPUT_TYPE,\n    amount: "0",\n    nftId: Converter.bytesToHex(initialNftId, true),\n    immutableFeatures: [\n        {\n            type: ISSUER_FEATURE_TYPE,\n            address: {\n                type: ED25519_ADDRESS_TYPE,\n                pubKeyHash: sourceAddress\n            }\n        },\n        {\n            type: METADATA_FEATURE_TYPE,\n            data: Converter.utf8ToHex(JSON.stringify(immutableData), true)\n        },\n    ],\n    unlockConditions: [\n        {\n            type: ADDRESS_UNLOCK_CONDITION_TYPE,\n            address: {\n                type: ED25519_ADDRESS_TYPE,\n                pubKeyHash: sourceAddress\n            }\n        }\n    ]\n};\n\nconst nftStorageCost = TransactionHelper.getStorageDeposit(nftOutput, nodeInfo.protocol.rentStructure);\nconst amountNeeded = bigInt(nftStorageCost).multiply(bigInt(2));\nnftOutput.amount = amountNeeded.toString();\n')),(0,o.kt)("h2",{id:"initialize-the-nft"},"Initialize the NFT"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"nftId")," is initialized as a hexadecimal string that represents ",(0,o.kt)("inlineCode",{parentName:"p"},"32")," bytes set to ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),". By doing this, you tell the\nrequest to mint a ",(0,o.kt)("strong",{parentName:"p"},"new")," NFT. The Output also includes two immutable features:\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"Issuer"),". It must be equal to the owner of the Input of the transaction that will create the NFT\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"metadata"),". This allows knowing information about the asset bound to the NFT. In this case,\nthe ",(0,o.kt)("a",{parentName:"p",href:"https://wiki.iota.org/shimmer/tips/tips/TIP-0027/"},"IRC27 standard")," is used to assert that the asset is an image\nhosted at a particular URI."),(0,o.kt)("h3",{id:"unlock-conditions"},"Unlock Conditions"),(0,o.kt)("p",null,"The unlock conditions set that the ",(0,o.kt)("inlineCode",{parentName:"p"},"sourceAddress")," is the one that owns this NFT. You will need to calculate the storage\ncosts of the NFT Output and assign it to the ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," held by the Output. In this case, the code transferred double the\nactual cost so that, if needed, the NFT Output can be expanded with extra metadata or unlock conditions."),(0,o.kt)("h2",{id:"define-the-transaction-essence"},"Define the Transaction Essence"),(0,o.kt)("p",null,"The transaction involves an Input (the Output that holds at least enough funds to cover the storage deposit of\nthe new NFT) and two Outputs. The new NFT Output and another Basic Output with the remaining funds from the original\nInput that you can only unlock with the original address that controls the funds."),(0,o.kt)("p",null,"To calculate the remaining funds, you need to query the node to obtain the details of the consumed Output."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const inputs: IUTXOInput[] = [];\nconst outputs: (INftOutput | IBasicOutput)[] = [];\n\ninputs.push(TransactionHelper.inputFromOutputId(consumedOutputId));\n\nconst consumedOutputDetails = await client.output(consumedOutputId);\nconst totalFunds = bigInt(consumedOutputDetails.output.amount);\n\nconst remainderBasicOutput: IBasicOutput = JSON.parse(JSON.stringify(consumedOutput));\n\nconst remainingFunds = bigInt(consumedOutput.amount).minus(bigInt(nftOutput.amount));\nremainderBasicOutput.amount = remainingFunds.toString();\n\noutputs.push(nftOutput);\noutputs.push(remainderBasicOutput);\n\nconst inputsCommitment = TransactionHelper.getInputsCommitment([consumedOutput]);\n\nconst transactionEssence: ITransactionEssence = {\n    type: TRANSACTION_ESSENCE_TYPE,\n    networkId: TransactionHelper.networkIdFromNetworkName(nodeInfo.protocol.networkName),\n    inputs,\n    inputsCommitment,\n    outputs\n};\n")),(0,o.kt)("h2",{id:"issue-the-transaction"},"Issue the Transaction"),(0,o.kt)("p",null,"Once the transaction essence is defined you can issue the transaction the same way as\nwith ",(0,o.kt)("a",{parentName:"p",href:"../value-transactions/transfer-funds/#create-a-transaction-payload"},"value transaction"),". You will need to sign the\nessence with the keys of the address that controls the initial Output, which will provide funds for your NFT (the\nstorage deposit as a minimum)."),(0,o.kt)("p",null,"After submitting the corresponding block with the Block ID, you can check the resulting outputs in\nthe ",(0,o.kt)("a",{parentName:"p",href:"https://explorer.shimmer.network/testnet"},"Tangle Explorer"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'const essenceHash = TransactionHelper.getTransactionEssenceHash(transactionEssence);\n\nconst unlockCondition: ISignatureUnlock = {\n    type: SIGNATURE_UNLOCK_TYPE,\n    signature: {\n        type: ED25519_SIGNATURE_TYPE,\n        publicKey: sourceAddressPublicKey,\n        signature: Converter.bytesToHex(Ed25519.sign(Converter.hexToBytes(sourceAddressPrivateKey), essenceHash), true)\n    }\n};\n\nconst transactionPayload: ITransactionPayload = {\n    type: TRANSACTION_PAYLOAD_TYPE,\n    essence: transactionEssence,\n    unlocks: [unlockCondition]\n};\n\nconst block: IBlock = {\n    protocolVersion: DEFAULT_PROTOCOL_VERSION,\n    parents: [],\n    payload: transactionPayload,\n    nonce: "0",\n};\n\nconsole.log("Calculating PoW, submitting block...");\nconst blockId = await client.blockSubmit(block);\nconsole.log("Block Id:", blockId);\n')),(0,o.kt)("h2",{id:"calculate-the-nft-id"},"Calculate the NFT ID"),(0,o.kt)("p",null,"It is important to understand that the new NFT ID is derived from the ID of the NFT Output. In turn, the ID of the NFT\nOutput is derived from the transaction ID. The transaction ID is a hash of the transaction payload. You can calculate it\nusing the function ",(0,o.kt)("inlineCode",{parentName:"p"},"computeTransactionIdFromTransactionPayload")," as shown below. The Output ID is\ncalculated using the function ",(0,o.kt)("inlineCode",{parentName:"p"},"TransactionHelper.outputIdFromTransactionData"),", and then the NFT ID is the Blake256 hash\nof the Output Id. Afterward, you can calculate the Bech32 address corresponding to the NFT ID using\nthe ",(0,o.kt)("a",{parentName:"p",href:"/shimmer/iotajs/references/client/classes/Bech32Helper"},(0,o.kt)("inlineCode",{parentName:"a"},"Bech32Helper"))," and specifying that it is an ",(0,o.kt)("inlineCode",{parentName:"p"},"NFT_ADDRESS_TYPE"),"."),(0,o.kt)("p",null,"Before querying the block, you can wait some seconds for confirmation and check through the ",(0,o.kt)("inlineCode",{parentName:"p"},"blockMetadata"),"\nfunction that the Ledger included your block."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'setTimeout(async () => {\n    const blockMetadata = await client.blockMetadata(blockId);\n    if (!blockMetadata.ledgerInclusionState) {\n        throw new Error("Block still pending confirmation");\n    }\n\n    if (blockMetadata.ledgerInclusionState === "included") {\n        const transactionId = calculateTransactionId(transactionPayload);\n        const outputId = TransactionHelper.outputIdFromTransactionData(transactionId, 0);\n        console.log("Output Id:", outputId);\n        const nftIdBytes = Blake2b.sum256(Converter.hexToBytes(outputID));\n        const nftId = Converter.bytesToHex(nftIdBytes, true)\n        console.log("NFT ID:", nftId);\n        console.log("NFT Address:",\n            Bech32Helper.toBech32(NFT_ADDRESS_TYPE, nftIdBytes, nodeInfo.protocol.bech32Hrp));\n    } else if (blockMetadata.ledgerInclusionState === "conflicting") {\n        throw new Error("Conflicting Block");\n    }\n}, 6000);\n\nfunction computeTransactionIdFromTransactionPayload(payload: ITransactionPayload) {\n    const tpWriteStream = new WriteStream();\n    serializeTransactionPayload(tpWriteStream, payload);\n    return Converter.bytesToHex(Blake2b.sum256(tpWriteStream.finalBytes()), true);\n}\n')),(0,o.kt)("p",null,"If you run the code above, you should get an output similar to:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"Block Id: 0xfd8fdb766f6e55afc52c4828cb93510530b7efcd7bdd55aadf8b8a01d6505b59\nOutput Id: 0xaced9bcc3b7b4ea5f55d19990de851dbe58676f2b3453a3a8bd780906154422e0000\nNFT ID: 0x601c1c6a67b25c453a2286f639a43f8a68aeb865bcc53632cb670e6afa2ad12a\nNFT Address: rms1zpspc8r2v7e9c3f6y2r0vwdy879x3t4cvk7v2d3jednsu6h69tgj5y8mzdm\n")),(0,o.kt)("p",null,"Remember that the NFT ID remains constant and known by every node regardless of the transactions (NFT Outputs\ngenerated) issued. That means you can query, through the ",(0,o.kt)("a",{parentName:"p",href:"https://explorer.shimmer.network/testnet"},"Tangle Explorer"),",\nfor instance, the current NFT Output of an\nNFT by supplying the NFT ID or its representation as a Bech32 address."),(0,o.kt)("h2",{id:"putting-it-all-together"},"Putting It All Together"),(0,o.kt)("p",null,"The complete source code of this part of the tutorial is available in\nthe ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/iotaledger/iota.js/blob/feat/stardust/packages/iota/examples/shimmer-nft-transaction-tutorial/src/mint-new-nft.ts"},"official iota.js GitHub repository"),"."))}p.isMDXComponent=!0}}]);