"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[67407],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(67294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,o=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),p=u(n),h=s,m=p["".concat(l,".").concat(h)]||p[h]||d[h]||o;return n?a.createElement(m,i(i({ref:t},c),{},{components:n})):a.createElement(m,i({ref:t},c))}));function h(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=n.length,i=new Array(o);i[0]=p;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:s,i[1]=r;for(var u=2;u<o;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},80579:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>u});var a=n(87462),s=(n(67294),n(3905));const o={description:"Mint a new Alias with iota.js.",image:"/img/client_banner.png",keywords:["tutorial","alias","address","output","mint"]},i="Mint a New Alias Address",r={unversionedId:"tutorials/alias-transactions/mint-new-alias",id:"tutorials/alias-transactions/mint-new-alias",title:"Mint a New Alias Address",description:"Mint a new Alias with iota.js.",source:"@site/shimmer/external/iota.js/documentation/docs/tutorials/alias-transactions/03-mint-new-alias.md",sourceDirName:"tutorials/alias-transactions",slug:"/tutorials/alias-transactions/mint-new-alias",permalink:"/shimmer/iotajs/tutorials/alias-transactions/mint-new-alias",draft:!1,editUrl:"https://github.com/iotaledger/iota.js/tree/dev/packages/iota/documentation/shimmer/external/iota.js/documentation/docs/tutorials/alias-transactions/03-mint-new-alias.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{description:"Mint a new Alias with iota.js.",image:"/img/client_banner.png",keywords:["tutorial","alias","address","output","mint"]},sidebar:"docs",previous:{title:"Prepare Your Development Environment",permalink:"/shimmer/iotajs/tutorials/alias-transactions/prepare-the-dev-env"},next:{title:"Create an Alias Transaction",permalink:"/shimmer/iotajs/tutorials/alias-transactions/alias-transaction"}},l={},u=[{value:"Define the Genesis Alias Output",id:"define-the-genesis-alias-output",level:2},{value:"Define the Transaction Essence",id:"define-the-transaction-essence",level:2},{value:"Issue the Transaction",id:"issue-the-transaction",level:2},{value:"Calculate the Alias ID",id:"calculate-the-alias-id",level:2}],c={toc:u};function d(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"mint-a-new-alias-address"},"Mint a New Alias Address"),(0,s.kt)("p",null,"You can use an ",(0,s.kt)("a",{parentName:"p",href:"https://wiki.iota.org/shimmer/introduction/explanations/ledger/alias/"},"Alias Output")," to store proof of the world state included in the ledger and never pruned. An Alias Output is associated with an Alias ID (also known as an ",(0,s.kt)("a",{parentName:"p",href:"#calculate-the-alias-id"},"Alias Address"),"). An Alias ID remains immutable during its lifetime."),(0,s.kt)("p",null,"For instance, an Alias Output can contain a hash or digital signature as a commitment to the state of a particular dynamic data set, as it happens with Smart Contracts. A data validator can use such proof to ensure that the concerned data has not been tampered with. When there is a change in the data, a transition to a new state is recorded on the ledger by a new transaction that generates a new Alias Output with the original Alias ID. The Alias ID remains constant, whereas a new Alias Output is generated to hold the new state."),(0,s.kt)("p",null,"Provided the proof size in bytes does not change between state changes, a new Alias Output does not need to increase its storage deposit."),(0,s.kt)("p",null,"To mint a new Alias and generate its genesis, you will need the following:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"An unspent Output that holds enough funds for the minimal storage deposit needed for the genesis Alias Output. In the Testnet, you can ",(0,s.kt)("a",{parentName:"p",href:"../value-transactions/request-funds-from-the-faucet/"},"request funds through the Faucet"),".")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"The key pair that corresponds to the Shimmer address that owns the output, as you need to unlock a certain amount of funds to cover the storage deposit of the new minted Alias.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"A State Controller Address. You will use the State Controller address private key to unlock the Alias Output of your new Alias so that it can transition to a new state when needed. If you haven\u2019t generated any addresses before, you can find detailed instructions in the ",(0,s.kt)("a",{parentName:"p",href:"../value-transactions/generate-addresses"},"Send Value Transactions tutorial"),".")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"A Governor Address. With the private key of the Governor, you will be able to change the State Controller Address or even destroy the Alias.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"The data you want to store on the Alias Output (represented as a hexadecimal string). Remember, the longer the data, the higher the storage deposit you will need."))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},'const consumedOutputId = "0x45678...";\n\n// Ed25519 Addresses (PubKeyHash)\nconst sourceAddress = "0x377a...";\n\n// Ed25519 Key pairs\nconst sourceAddressPublicKey = "0x1be6ea...";\nconst sourceAddressPrivateKey = "0xb2a5c46a...";\n\n// Ed25519 Addresses (PubKeyHash)\nconst stateControllerAddress = "0x647f7a9fd831c6e6034e7e5496a50aed17ef7d2add200bb4cfde7649ce2b0aaf";\nconst governorAddress = "0x22847390aad479d34d52e4fb58a01d752887ae0247708f7e66b488c5b5ba2751";\n\nconst client = new SingleNodeClient(API_ENDPOINT, { powProvider: new NeonPowProvider() });\nconst protocolInfo = await client.protocolInfo();\n')),(0,s.kt)("h2",{id:"define-the-genesis-alias-output"},"Define the Genesis Alias Output"),(0,s.kt)("p",null,"You can define the genesis (initial) Alias Output to mint your Alias with the following snippet:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},'const initialAliasId = new Uint8Array(new ArrayBuffer(32));\n\nconst aliasOutput: IAliasOutput = {\n    type: ALIAS_OUTPUT_TYPE,\n    amount: amountToSend.toString(),\n    aliasId: Converter.bytesToHex(initialAliasId, true),\n    stateMetadata: "0x12345678",\n    stateIndex: 0,\n    foundryCounter: 0,\n    unlockConditions: [\n        {\n            type: STATE_CONTROLLER_ADDRESS_UNLOCK_CONDITION_TYPE,\n            address: {\n                type: ED25519_ADDRESS_TYPE,\n                pubKeyHash: stateControllerAddress\n            }\n        },\n        {\n            type: GOVERNOR_ADDRESS_UNLOCK_CONDITION_TYPE,\n            address: {\n                type: ED25519_ADDRESS_TYPE,\n                pubKeyHash: governorAddress\n            }\n        }\n    ]\n};\n')),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"aliasId")," is initialized as a hexadecimal string that represents ",(0,s.kt)("inlineCode",{parentName:"p"},"32")," bytes set to ",(0,s.kt)("inlineCode",{parentName:"p"},"0"),". That is the way to ask for a new Alias to be minted. The ",(0,s.kt)("inlineCode",{parentName:"p"},"stateIndex")," is initialized as ",(0,s.kt)("inlineCode",{parentName:"p"},"0"),", as this is the initial state. In the unlock conditions, the State Controller and Governor addresses are specified in their Ed25519 hashed representation."),(0,s.kt)("h2",{id:"define-the-transaction-essence"},"Define the Transaction Essence"),(0,s.kt)("p",null,"The transaction you are defining involves an input (the output that holds enough funds to cover the storage deposit of the new Alias) and two outputs:\nThe new Alias Output\nA Basic Output that holds the remaining funds from the original input. You can only unlock this output with the original address that controls the funds."),(0,s.kt)("p",null,"In this case, you manually assign an amount to send to the Alias Output (",(0,s.kt)("inlineCode",{parentName:"p"},"60000 Glow"),") so that it covers its storage deposit. In a real-world scenario, you may need to automatically calculate the storage deposit as per the byte rent costs published by your node."),(0,s.kt)("p",null,"You can calculate the remaining funds by sending a query to the node to obtain the details of the consumed output. You can use the following snippet to do so:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},' const inputs: IUTXOInput[] = [];\nconst outputs: (IAliasOutput | IBasicOutput)[] = [];\n\n// The number of funds to be sent to an alias output so that it covers its byte costs\nconst amountToSend = bigInt("60000");\n\ninputs.push(TransactionHelper.inputFromOutputId(consumedOutputId));\n\n// Details the of consumed Output\nconst consumedOutputDetails = await client.output(consumedOutputId);\nconst totalFunds = bigInt(consumedOutputDetails.output.amount);\n\n// The remaining output remains in the origin address\nconst remainderBasicOutput: IBasicOutput = {\n    type: BASIC_OUTPUT_TYPE,\n    amount: totalFunds.minus(amountToSend).toString(),\n    nativeTokens: [],\n    unlockConditions: [\n        {\n           type: ADDRESS_UNLOCK_CONDITION_TYPE,\n            address: {\n                type: ED25519_ADDRESS_TYPE,\n                pubKeyHash: sourceAddress\n            }\n        }\n    ],\n    features: []\n};\n\noutputs.push(aliasOutput);\noutputs.push(remainderBasicOutput);\n\n// Get inputs commitment\nconst inputsCommitment = TransactionHelper.getInputsCommitment([consumedOutputDetails.output]);\n\n// Create transaction essence\nconst transactionEssence: ITransactionEssence = {\n    type: TRANSACTION_ESSENCE_TYPE,\n    networkId: protocolInfo.networkId,\n    inputs,\n    inputsCommitment,\n    outputs\n};\n')),(0,s.kt)("h2",{id:"issue-the-transaction"},"Issue the Transaction"),(0,s.kt)("p",null,"Once you have defined the transaction essence, you can ",(0,s.kt)("a",{parentName:"p",href:"../value-transactions/transfer-funds/#create-a-transaction-payload"},"issue the transaction"),". You will need to sign the essence with the keys of the address that controls the initial output that will provide funds for the Alias output (the storage deposit as a minimum)."),(0,s.kt)("p",null,"After submitting the block with the Block ID, you can check the ",(0,s.kt)("a",{parentName:"p",href:"https://explorer.shimmer.network/testnet"},"Tangle Explorer")," for the resulting outputs."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},'const wsTsxEssence = new WriteStream();\nserializeTransactionEssence(wsTsxEssence, transactionEssence);\nconst essenceFinal = wsTsxEssence.finalBytes();\n\nconst essenceHash = Blake2b.sum256(essenceFinal);\n   \nconst unlockCondition: ISignatureUnlock = {\n    type: SIGNATURE_UNLOCK_TYPE,\n    signature: {\n        type: ED25519_SIGNATURE_TYPE,\n        publicKey: sourceAddressPublicKey,\n        signature: Converter.bytesToHex(Ed25519.sign(Converter.hexToBytes(sourceAddressPrivateKey), essenceHash), true)\n    }\n};\n\nconst transactionPayload: ITransactionPayload = {\n    type: TRANSACTION_PAYLOAD_TYPE,\n    essence: transactionEssence,\n    unlocks: [unlockCondition]\n};\n\nconst block: IBlock = {\n    protocolVersion: DEFAULT_PROTOCOL_VERSION,\n    parents: [],\n    payload: transactionPayload,\n    nonce: "0",\n};\n\nconst blockId = await client.blockSubmit(block);\nconsole.log("Block Id:", blockId);\n')),(0,s.kt)("h2",{id:"calculate-the-alias-id"},"Calculate the Alias ID"),(0,s.kt)("p",null,"It is important to understand that the new Alias ID is derived from the ID of the Alias Output, and the ID of the Alias Output is derived from the ID of the transaction. The transaction ID is a hash of the transaction payload, which can be calculated using the function ",(0,s.kt)("inlineCode",{parentName:"p"},"computeTransactionIdFromTransactionPayload")," as shown below. The output ID is calculated using the function ",(0,s.kt)("a",{parentName:"p",href:"../../references/client/classes/TransactionHelper#outputidfromtransactiondata"},(0,s.kt)("inlineCode",{parentName:"a"},"TransactionHelper.outputIdFromTransactionData")),", and the Alias Id is the Blake256 hash of an Output Id. You can calculate the Bech32 address corresponding to the Alias Id using the ",(0,s.kt)("a",{parentName:"p",href:"../../references/client/classes/Bech32Helper"},(0,s.kt)("inlineCode",{parentName:"a"},"Bech32Helper"))," and specifying that it is an ",(0,s.kt)("inlineCode",{parentName:"p"},"ALIAS_ADDRESS_TYPE"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},'const blockData: IBlock = await client.block(blockId);\nconst blockTransactionPayload = blockData.payload as ITransactionPayload;\n\nconst transactionId = computeTransactionIdFromTransactionPayload(blockTransactionPayload);\nconst outputId = TransactionHelper.outputIdFromTransactionData(transactionId, 0);\nconsole.log("Output Id:", outputId);\n\nconst addrHash = Blake2b.sum256(Converter.hexToBytes(outputId));\nconsole.log("Alias ID:", Converter.bytesToHex(addrHash, true));\nconsole.log("Alias Address:", Bech32Helper.toBech32(ALIAS_ADDRESS_TYPE, addrHash, protocolInfo.bech32Hrp));\n\nfunction computeTransactionIdFromTransactionPayload(payload: ITransactionPayload) {\n  const tpWriteStream = new WriteStream();\n  serializeTransactionPayload(tpWriteStream, payload);\n  return Converter.bytesToHex(Blake2b.sum256(tpWriteStream.finalBytes()), true);\n}\n')),(0,s.kt)("p",null,"The code above will result in something similar to the following:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-text"},"Block Id: 0x2817e61f5a559a7521e2e20dfc69f0e184a6fa00109a05fa040a9d6cb6d292e1\nOutput Id: 0x6e23b48b4f4e5683832c4b53d598b00d769ba2a7305c9c0cdeefb0246b894f330000\nAlias ID: 0x6dd4b53990a862f7afaa19b58c5566970d7c40482547abd50a3a6de9f9ad4b14\nAlias Address: rms1ppkafdfejz5x9aa04gvmtrz4v6ts6lzqfqj50274pgaxm60e4493gdry4ys\n")),(0,s.kt)("p",null,"Remember that the Alias ID remains constant and known by every node software regardless of the transactions (Alias Outputs generated) issued. That means you can query through the Tangle Explorer, for instance, the current Alias Output of an Alias Id by just supplying the Alias Id or its representation as a Bech32 address."))}d.isMDXComponent=!0}}]);