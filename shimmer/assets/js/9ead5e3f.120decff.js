"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[15316],{3905:(t,e,n)=>{n.d(e,{Zo:()=>c,kt:()=>m});var a=n(67294);function i(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function s(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function o(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?s(Object(n),!0).forEach((function(e){i(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function r(t,e){if(null==t)return{};var n,a,i=function(t,e){if(null==t)return{};var n,a,i={},s=Object.keys(t);for(a=0;a<s.length;a++)n=s[a],e.indexOf(n)>=0||(i[n]=t[n]);return i}(t,e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);for(a=0;a<s.length;a++)n=s[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(i[n]=t[n])}return i}var l=a.createContext({}),u=function(t){var e=a.useContext(l),n=e;return t&&(n="function"==typeof t?t(e):o(o({},e),t)),n},c=function(t){var e=u(t.components);return a.createElement(l.Provider,{value:e},t.children)},p={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},d=a.forwardRef((function(t,e){var n=t.components,i=t.mdxType,s=t.originalType,l=t.parentName,c=r(t,["components","mdxType","originalType","parentName"]),d=u(n),m=i,h=d["".concat(l,".").concat(m)]||d[m]||p[m]||s;return n?a.createElement(h,o(o({ref:e},c),{},{components:n})):a.createElement(h,o({ref:e},c))}));function m(t,e){var n=arguments,i=e&&e.mdxType;if("string"==typeof t||i){var s=n.length,o=new Array(s);o[0]=d;var r={};for(var l in e)hasOwnProperty.call(e,l)&&(r[l]=e[l]);r.originalType=t,r.mdxType="string"==typeof t?t:i,o[1]=r;for(var u=2;u<s;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},36605:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>u});var a=n(87462),i=(n(67294),n(3905));const s={description:"Perform an Alias Transaction with iota.js.",image:"/img/client_banner.png",keywords:["tutorial","alias","output","transaction"]},o="Create an Alias Transaction",r={unversionedId:"tutorials/alias-transactions/alias-transaction",id:"tutorials/alias-transactions/alias-transaction",title:"Create an Alias Transaction",description:"Perform an Alias Transaction with iota.js.",source:"@site/shimmer/external/iota.js/documentation/docs/tutorials/alias-transactions/04-alias-transaction.md",sourceDirName:"tutorials/alias-transactions",slug:"/tutorials/alias-transactions/alias-transaction",permalink:"/shimmer/iotajs/tutorials/alias-transactions/alias-transaction",draft:!1,editUrl:"https://github.com/iotaledger/iota.js/tree/dev/packages/iota/documentation/shimmer/external/iota.js/documentation/docs/tutorials/alias-transactions/04-alias-transaction.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{description:"Perform an Alias Transaction with iota.js.",image:"/img/client_banner.png",keywords:["tutorial","alias","output","transaction"]},sidebar:"docs",previous:{title:"Mint a New Alias Address",permalink:"/shimmer/iotajs/tutorials/alias-transactions/mint-new-alias"},next:{title:"@iota/iota.js",permalink:"/shimmer/iotajs/references/client/api_ref"}},l={},u=[{value:"Preparation",id:"preparation",level:2},{value:"Query Alias Output",id:"query-alias-output",level:2},{value:"Assign the New State",id:"assign-the-new-state",level:2},{value:"Define the Transaction",id:"define-the-transaction",level:2},{value:"Provide the Unlock Conditions",id:"provide-the-unlock-conditions",level:2},{value:"Submit the Block",id:"submit-the-block",level:2}],c={toc:u};function p(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"create-an-alias-transaction"},"Create an Alias Transaction"),(0,i.kt)("p",null,"The State Controller of an Alias can perform transactions that change the Alias to a new state. The transaction generates a new Alias Output with the Alias ID of the original Alias. Remember that the Alias ID remains constant regardless of the Alias Output that holds the funds and the state metadata. The ",(0,i.kt)("strong",{parentName:"p"},"Alias Output Id"),' changes, and once it is "spent", it is pruned from the ledger.'),(0,i.kt)("h2",{id:"preparation"},"Preparation"),(0,i.kt)("p",null,"To create this transaction, you will need the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A Shimmer Node. You can use the ",(0,i.kt)("a",{parentName:"p",href:"https://api.testnet.shimmer.network"},"Shimmer Testnet nodes"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The Alias ID of your Alias, in hexadecimal format ",(0,i.kt)("inlineCode",{parentName:"p"},"0x6dd4..."),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The keys of the state controller of your Alias."))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'const client = new SingleNodeClient(API_ENDPOINT, { powProvider: new NeonPowProvider() });\nconst protocolInfo = await client.protocolInfo();\n\nconst stateControllerPubKey = "0x55419...";\nconst stateControllerPrivateKey = "0xa060ff...";\n')),(0,i.kt)("h2",{id:"query-alias-output"},"Query Alias Output"),(0,i.kt)("p",null,"You will first need to find the Alias Output of your Alias. The easiest way to do so is through a query to the ",(0,i.kt)("a",{parentName:"p",href:"https://wiki.iota.org/shimmer/inx-indexer/welcome/"},"indexation plugin")," by Alias ID. Observe that you need to obtain the full output details as we need to use them as input for the transaction."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'const indexerPlugin = new IndexerPluginClient(client);\nconst outputList = await indexerPlugin.alias(aliasId);\nconst consumedOutputId = outputList.items[0];\nconsole.log("Consumed Output Id", consumedOutputId);\n\nconst initialAliasOutputDetails = await client.output(consumedOutputId);\nconst initialAliasOutput: IAliasOutput = initialAliasOutputDetails.output as IAliasOutput;\n')),(0,i.kt)("h2",{id:"assign-the-new-state"},"Assign the New State"),(0,i.kt)("p",null,"To continue, you can create the new Alias Output by cloning the one received in the ",(0,i.kt)("a",{parentName:"p",href:"#query-alias-output"},"previous step"),", and then increment the ",(0,i.kt)("inlineCode",{parentName:"p"},"stateIndex")," and set the new ",(0,i.kt)("inlineCode",{parentName:"p"},"stateMetadata"),". Now, you are ready to define the transaction. You should ensure that you assign the correct ",(0,i.kt)("inlineCode",{parentName:"p"},"aliasId")," to your new Alias Output."),(0,i.kt)("p",null,"As the proof size does not change between state changes, your new Alias Output does not need to increase its storage deposit."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'const nextAliasOutput: IAliasOutput = JSON.parse(JSON.stringify(initialAliasOutput));\nnextAliasOutput.stateIndex++;\nnextAliasOutput.stateMetadata = "0x98765";\nconsole.log("New state index: ", nextAliasOutput.stateIndex);\nnextAliasOutput.aliasId = aliasId;\n')),(0,i.kt)("h2",{id:"define-the-transaction"},"Define the Transaction"),(0,i.kt)("p",null,"The transaction takes the original Alias Output as input and generates a new Alias Output with the new state but keeps the original Alias ID."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const inputs: IUTXOInput[] = [];\nconst outputs: IAliasOutput[] = [];\n\ninputs.push(TransactionHelper.inputFromOutputId(consumedOutputId));\noutputs.push(nextAliasOutput);\n\nconst inputsCommitment = TransactionHelper.getInputsCommitment([initialAliasOutput]);\n\nconst transactionEssence: ITransactionEssence = {\n    type: TRANSACTION_ESSENCE_TYPE,\n    networkId: protocolInfo.networkId,\n    inputs,\n    inputsCommitment,\n    outputs\n};\n")),(0,i.kt)("h2",{id:"provide-the-unlock-conditions"},"Provide the Unlock Conditions"),(0,i.kt)("p",null,"The unlock conditions you need to provide correspond to the State Controller signature calculated against the transaction essence."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const wsTsxEssence = new WriteStream();\nserializeTransactionEssence(wsTsxEssence, transactionEssence);\nconst essenceFinal = wsTsxEssence.finalBytes();\n\nconst essenceHash = Blake2b.sum256(essenceFinal);\n\nconst unlockCondition: ISignatureUnlock = {\n    type: SIGNATURE_UNLOCK_TYPE,\n    signature: {\n        type: ED25519_SIGNATURE_TYPE,\n        publicKey: stateControllerPubKey,\n        signature: Converter.bytesToHex(Ed25519.sign(Converter.hexToBytes(stateControllerPrivateKey), essenceHash), true)\n    }\n};\n\nconst transactionPayload: ITransactionPayload = {\n    type: TRANSACTION_PAYLOAD_TYPE,\n    essence: transactionEssence,\n    unlocks: [unlockCondition]\n};   \n")),(0,i.kt)("h2",{id:"submit-the-block"},"Submit the Block"),(0,i.kt)("p",null,"Finally, you should submit the block. After the block is confirmed, if you query your Alias Address through ",(0,i.kt)("a",{parentName:"p",href:"https://explorer.shimmer.network/shimmer"},"the Shimmer Explorer"),", you will find the new Alias Output with the updated state."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'const block: IBlock = {\n    protocolVersion: DEFAULT_PROTOCOL_VERSION,\n    parents: [],\n    payload: transactionPayload,\n    nonce: "0",\n};\n\nconst blockId = await client.blockSubmit(block);\nconsole.log("Block Id:", blockId);\n')))}p.isMDXComponent=!0}}]);