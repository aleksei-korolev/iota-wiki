"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[28500],{3905:(t,e,n)=>{n.d(e,{Zo:()=>p,kt:()=>h});var o=n(67294);function a(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,o)}return n}function s(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach((function(e){a(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function r(t,e){if(null==t)return{};var n,o,a=function(t,e){if(null==t)return{};var n,o,a={},i=Object.keys(t);for(o=0;o<i.length;o++)n=i[o],e.indexOf(n)>=0||(a[n]=t[n]);return a}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(o=0;o<i.length;o++)n=i[o],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(a[n]=t[n])}return a}var u=o.createContext({}),l=function(t){var e=o.useContext(u),n=e;return t&&(n="function"==typeof t?t(e):s(s({},e),t)),n},p=function(t){var e=l(t.components);return o.createElement(u.Provider,{value:e},t.children)},d={inlineCode:"code",wrapper:function(t){var e=t.children;return o.createElement(o.Fragment,{},e)}},c=o.forwardRef((function(t,e){var n=t.components,a=t.mdxType,i=t.originalType,u=t.parentName,p=r(t,["components","mdxType","originalType","parentName"]),c=l(n),h=a,k=c["".concat(u,".").concat(h)]||c[h]||d[h]||i;return n?o.createElement(k,s(s({ref:e},p),{},{components:n})):o.createElement(k,s({ref:e},p))}));function h(t,e){var n=arguments,a=e&&e.mdxType;if("string"==typeof t||a){var i=n.length,s=new Array(i);s[0]=c;var r={};for(var u in e)hasOwnProperty.call(e,u)&&(r[u]=e[u]);r.originalType=t,r.mdxType="string"==typeof t?t:a,s[1]=r;for(var l=2;l<i;l++)s[l]=n[l];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}c.displayName="MDXCreateElement"},60847:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>u,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var o=n(87462),a=(n(67294),n(3905));const i={description:"Melt native tokens with iota.js.",image:"/img/client_banner.png",keywords:["tutorial","alias","address","output","melt","foundry","native tokens","token","digital","asset"]},s="Melting Native Tokens",r={unversionedId:"tutorials/native-token-transactions/melt-native-tokens",id:"tutorials/native-token-transactions/melt-native-tokens",title:"Melting Native Tokens",description:"Melt native tokens with iota.js.",source:"@site/shimmer/external/iota.js/documentation/docs/tutorials/native-token-transactions/05-melt-native-tokens.md",sourceDirName:"tutorials/native-token-transactions",slug:"/tutorials/native-token-transactions/melt-native-tokens",permalink:"/shimmer/iotajs/tutorials/native-token-transactions/melt-native-tokens",draft:!1,editUrl:"https://github.com/iotaledger/iota.js/tree/dev/packages/iota/documentation/shimmer/external/iota.js/documentation/docs/tutorials/native-token-transactions/05-melt-native-tokens.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{description:"Melt native tokens with iota.js.",image:"/img/client_banner.png",keywords:["tutorial","alias","address","output","melt","foundry","native tokens","token","digital","asset"]},sidebar:"docs",previous:{title:"Send Native Tokens",permalink:"/shimmer/iotajs/tutorials/native-token-transactions/native-tokens-transaction"},next:{title:"Stardust for iota.js: NFT Transactions",permalink:"/shimmer/iotajs/tutorials/nft-transactions/introduction"}},u={},l=[{value:"Preparation",id:"preparation",level:2},{value:"Set the New State of Your Alias Address",id:"set-the-new-state-of-your-alias-address",level:2},{value:"Query for the Alias Output",id:"query-for-the-alias-output",level:3},{value:"Assign the New State of the Alias",id:"assign-the-new-state-of-the-alias",level:3},{value:"Set the New State of Your Foundry",id:"set-the-new-state-of-your-foundry",level:2},{value:"Query for the Foundry Output",id:"query-for-the-foundry-output",level:3},{value:"Query for the Native Tokens Output",id:"query-for-the-native-tokens-output",level:3},{value:"Set the Amount of Melted Tokens on the Foundry",id:"set-the-amount-of-melted-tokens-on-the-foundry",level:3},{value:"Create the Remainder Output",id:"create-the-remainder-output",level:2},{value:"Define the transaction",id:"define-the-transaction",level:2},{value:"Define the Inputs and Outputs",id:"define-the-inputs-and-outputs",level:3},{value:"Provide the Unlocks",id:"provide-the-unlocks",level:2},{value:"Submit the blockB",id:"submit-the-blockb",level:2},{value:"Putting It All Together",id:"putting-it-all-together",level:2}],p={toc:l};function d(t){let{components:e,...n}=t;return(0,a.kt)("wrapper",(0,o.Z)({},p,n,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"melting-native-tokens"},"Melting Native Tokens"),(0,a.kt)("p",null,"This section in the tutorial will show you how to transition an existing Foundry Output to a new state. Specifically, how to melt the tokens that were transferred to an Output where you ",(0,a.kt)("a",{parentName:"p",href:"/shimmer/iotajs/tutorials/native-token-transactions/native-tokens-transaction"},"sent your native tokens"),"."),(0,a.kt)("p",null,"This transaction will involve three Inputs and three Outputs:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Input #1"),": The unspent Output of the Alias Address that controls your Foundry, created when you ",(0,a.kt)("a",{parentName:"p",href:"/shimmer/iotajs/tutorials/native-token-transactions/mint-native-tokens#prepare-the-alias-address"},"minted your native tokens"),".")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Input #2"),": The Foundry Output you created when you ",(0,a.kt)("a",{parentName:"p",href:"/shimmer/iotajs/tutorials/native-token-transactions/mint-native-tokens#define-the-foundry-output"},"minted your native tokens"),", controlled by your ","[Alias Address]","(](/shimmer/iotajs/tutorials/native-token-transactions/mint-native-tokens#prepare-the-alias-address) and corresponds to the serial number ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),".")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Input #3"),": The UTXO created in ",(0,a.kt)("a",{parentName:"p",href:"/shimmer/iotajs/tutorials/native-token-transactions/native-tokens-transaction#define-the-new-native-tokens-output"},"when you sent native tokens")," that holds ",(0,a.kt)("inlineCode",{parentName:"p"},"12")," native tokens that you are going to melt by issuing this transaction.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Output #1"),": The next Alias Output that captures the state of your Alias Address.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Output #2"),": The next Foundry Output that captures the next state of your Foundry. It declares the melted tokens after transaction confirmation.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Output #3"),": The same as ",(0,a.kt)("strong",{parentName:"p"},"Input #3")," but without any native tokens, as you will have melted them."))),(0,a.kt)("h2",{id:"preparation"},"Preparation"),(0,a.kt)("p",null,"To perform the transaction that will melt the native tokens, you will need:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"A Shimmer Node. You can use the ",(0,a.kt)("a",{parentName:"p",href:"https://api.testnet.shimmer.network"},"Shimmer Testnet nodes"),".")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The Alias ID of your Alias, in hexadecimal format ",(0,a.kt)("inlineCode",{parentName:"p"},"0x6dd4..."),".")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The keys of the State Controller of your Alias.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The address (and keys) that holds the native tokens to be melted ",(0,a.kt)("inlineCode",{parentName:"p"},"rms1qryyzvm..."),"."))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'const aliasId = process.argv[2];\nif (!aliasId) {\n    console.error("Please provide your Alias Id");\n    process.exit(-1);\n}\n\nconst client = new SingleNodeClient(API_ENDPOINT, { powProvider: new NeonPowProvider() });\nconst nodeInfo = await client.info();\nconst protocolInfo = nodeInfo.protocol;\n\nconst stateControllerAddress = "0x647f...";\nconst stateControllerPubKey = "0x55419...";\nconst stateControllerPrivateKey = "0xa060f...";\n\nconst nativeTokenOwnerAddress = "0xc8413...";\nconst nativeTokenOwnerAddressBech32 = "rms1qryyzvmx...";\nconst nativeTokenOwnerPubKey = "0xa5e76a...";\nconst nativeTokenOwnerPrivateKey = "0xc4e210...";\n')),(0,a.kt)("h2",{id:"set-the-new-state-of-your-alias-address"},"Set the New State of Your Alias Address"),(0,a.kt)("p",null,"In this step, you need to transition the Alias Address to a new state, as one of its bound elements, the Foundry, is changing its state."),(0,a.kt)("h3",{id:"query-for-the-alias-output"},"Query for the Alias Output"),(0,a.kt)("p",null,"First, you need to find the unspent Alias Output of your Alias Address through a query to the ",(0,a.kt)("a",{parentName:"p",href:"https://wiki.iota.org/shimmer/inx-indexer/welcome/"},"indexing plugin")," using the Alias ID. You need to obtain the full Output details, as you will need to use it as Input for your transaction."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'const indexerPlugin = new IndexerPluginClient(client);\nconst outputList = await indexerPlugin.alias(aliasId);\nconst consumedOutputID = outputList.items[0];\nconsole.log("Consumed Output Id", consumedOutputID);\n\nconst initialAliasOutputDetails = await client.output(consumedOutputID);\nconst initialAliasOutput: IAliasOutput = initialAliasOutputDetails.output as IAliasOutput;\n')),(0,a.kt)("h3",{id:"assign-the-new-state-of-the-alias"},"Assign the New State of the Alias"),(0,a.kt)("p",null,"To continue, you can create the next Alias Output by cloning the one obtained in the ",(0,a.kt)("a",{parentName:"p",href:"#query-for-the-alias-output"},"previous step"),", and then increment the ",(0,a.kt)("inlineCode",{parentName:"p"},"stateIndex"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const nextAliasOutput: IAliasOutput = JSON.parse(JSON.stringify(initialAliasOutput));\nnextAliasOutput.stateIndex++;\n")),(0,a.kt)("p",null,"At the end of this step, you know both ",(0,a.kt)("strong",{parentName:"p"},"Input #1")," and ",(0,a.kt)("strong",{parentName:"p"},"Output #1"),"."),(0,a.kt)("h2",{id:"set-the-new-state-of-your-foundry"},"Set the New State of Your Foundry"),(0,a.kt)("p",null,"In this step, you need to transition your Foundry to a new state, as some tokens will be put in ",(0,a.kt)("strong",{parentName:"p"},"melted")," state."),(0,a.kt)("h3",{id:"query-for-the-foundry-output"},"Query for the Foundry Output"),(0,a.kt)("p",null,"First, you need to find the unspent Foundry Output to transition by sending a query to the indexing plugin using the Alias Address. You need to obtain the full Output details as you will need to use it as Input for your transaction."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'const aliasIdBech32 = Bech32Helper.toBech32(ALIAS_ADDRESS_TYPE, Converter.hexToBytes(aliasId), protocolInfo.bech32Hrp);\nconst foundryList = await indexerPlugin.foundries({\n    aliasAddressBech32: aliasIdBech32\n});\nif (foundryList.items.length === 0) {\n    throw new Error("Foundry Output not found");\n}\n\nconst foundryOutputID = foundryList.items[0];\n\nconst initialFoundryOutputDetails = await client.output(foundryOutputID);\nconst initialFoundryOutput: IFoundryOutput = initialFoundryOutputDetails.output as IFoundryOutput;\n')),(0,a.kt)("p",null,"Keep in mind that you will need to use the ",(0,a.kt)("inlineCode",{parentName:"p"},"Bech32Helper.toBech32(bech32Text, humanReadablePart)"),"(references/client/classes/Bech32Helper/#frombech32) function to convert your Alias ID to a Bech32 address to match the format of the parameter expected by the indexing plugin."),(0,a.kt)("p",null,"At the end of this step, you know ",(0,a.kt)("strong",{parentName:"p"},"Input #2"),"."),(0,a.kt)("h3",{id:"query-for-the-native-tokens-output"},"Query for the Native Tokens Output"),(0,a.kt)("p",null,"As you are going to melt all the tokens of your formerly created Output, you need to perform a query to obtain its ID and the number of native tokens involved. You will also use this Output as ",(0,a.kt)("strong",{parentName:"p"},"Input #3")," of the transaction."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'const tokenClassId: string = TransactionHelper.constructTokenId(\n    initialAliasOutput.aliasId,\n    initialFoundryOutput.serialNumber,\n    initialFoundryOutput.tokenScheme.type\n);\n\nconst outputWithTokensToMeltList = await indexerPlugin.basicOutputs({\n    addressBech32: nativeTokenOwnerAddressBech32,\n    hasNativeTokens: true\n});\n\nif (outputWithTokensToMeltList.items.length === 0) {\n    throw new Error("There are no outputs with native tokens");\n}\n\n// We assume the first one is the right one\nconst outputWithTokensToMeltID = outputWithTokensToMeltList.items[0];\nconst outputWithTokensToMeltDetails = await client.output(outputWithTokensToMeltID);\nconst outputWithTokensToMelt = outputWithTokensToMeltDetails.output as IBasicOutput;\n\nif (!outputWithTokensToMelt.nativeTokens?.some(element => element.id === tokenClassId)) {\n    throw new Error("Unexpected token class Id");\n}\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"some")," function check that the Output actually holds native tokens of the expected class ID."),(0,a.kt)("p",null,"At the end of this step, you know ",(0,a.kt)("strong",{parentName:"p"},"Input #3"),"."),(0,a.kt)("h3",{id:"set-the-amount-of-melted-tokens-on-the-foundry"},"Set the Amount of Melted Tokens on the Foundry"),(0,a.kt)("p",null,"Once you know how many tokens you are going to melt, you just need to set the ",(0,a.kt)("inlineCode",{parentName:"p"},"meltedTokens")," field of the next Foundry Output."),(0,a.kt)("p",null,"As an Output can hold tokens of many classes at the same time, you should use the ",(0,a.kt)("inlineCode",{parentName:"p"},"findIndex")," function to ensure you are referring to the right token class. In this simple case, you can check that ",(0,a.kt)("inlineCode",{parentName:"p"},"index")," is equal to ",(0,a.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const index = outputWithTokensToMelt.nativeTokens?.findIndex(element => element.id === tokenClassId);\n\nnextFoundryOutput.tokenScheme.meltedTokens = outputWithTokensToMelt.nativeTokens[index].amount;\n")),(0,a.kt)("p",null,"At the end of this step, you know ",(0,a.kt)("strong",{parentName:"p"},"Output #2"),"."),(0,a.kt)("h2",{id:"create-the-remainder-output"},"Create the Remainder Output"),(0,a.kt)("p",null,"In this step, you must create the remainder Output. The remainder Output will be the same as ",(0,a.kt)("strong",{parentName:"p"},"Input #3")," except for the native tokens of ",(0,a.kt)("inlineCode",{parentName:"p"},"tokenClassId")," that are removed from the Output."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const remainderOutput = JSON.parse(JSON.stringify(outputWithTokensToMelt)) as IBasicOutput;\n\n// No longer have native tokens (assumption: there is only one entry of native tokens of tokenClassId)\nremainderOutput.nativeTokens = remainderOutput.nativeTokens?.filter((element) => {\n    element.id !== tokenClassId\n});\n")),(0,a.kt)("p",null,"At the end of this step you know, ",(0,a.kt)("strong",{parentName:"p"},"Output #3"),"."),(0,a.kt)("h2",{id:"define-the-transaction"},"Define the transaction"),(0,a.kt)("h3",{id:"define-the-inputs-and-outputs"},"Define the Inputs and Outputs"),(0,a.kt)("p",null,"Now, you can create the transaction essence to melt your native tokens as shown in the following snippet:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const inputs: IUTXOInput[] = [];\nconst outputs: (IAliasOutput | IFoundryOutput | IBasicOutput)[] = [];\n\ninputs.push(TransactionHelper.inputFromOutputId(consumedOutputID));\ninputs.push(TransactionHelper.inputFromOutputId(foundryOutputID));\ninputs.push(TransactionHelper.inputFromOutputId(outputWithTokensToMeltID));\n\noutputs.push(nextAliasOutput);\noutputs.push(nextFoundryOutput);\noutputs.push(remainderOutput);\n\nconst inputsCommitment = TransactionHelper.getInputsCommitment([\n    initialAliasOutput, initialFoundryOutput, outputWithTokensToMelt\n]);\n\nconst transactionEssence: ITransactionEssence = {\n    type: TRANSACTION_ESSENCE_TYPE,\n    networkId: TransactionHelper.networkIdFromNetworkName(protocolInfo.networkName),\n    inputs,\n    inputsCommitment,\n    outputs\n};\n")),(0,a.kt)("p",null,"At the end of this step, you have defined the transaction essence. It includes three Inputs:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Input #1"),": From ",(0,a.kt)("inlineCode",{parentName:"li"},"consumedOutputID"),", the unspent Alias Output of the Alias Address."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Input #2"),": From ",(0,a.kt)("inlineCode",{parentName:"li"},"foundryOutputID"),", the unspent Foundry Output owned by the Alias Address."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Input #3"),": From ",(0,a.kt)("inlineCode",{parentName:"li"},"outputWithTokensToMeltID"),", the Basic Output holding native tokens.")),(0,a.kt)("p",null,"And three Outputs:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Output #1"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"nextAliasOutput"),", the next Alias Output of the Alias Address."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Output #2"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"nextFoundryOutput"),", the next Foundry Output, now declaring melted tokens."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Output #3"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"remainderOutput"),", the remainder of the Basic Output with no native tokens of ",(0,a.kt)("inlineCode",{parentName:"li"},"tokenClassID"),".")),(0,a.kt)("h2",{id:"provide-the-unlocks"},"Provide the Unlocks"),(0,a.kt)("p",null,"In this case, you need to provide three unlocks::"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The State Controller unlock signature for the Alias Output."),(0,a.kt)("li",{parentName:"ul"},"The reference to the former to unlock the Foundry Output. Remember that the Alias controls the Foundry."),(0,a.kt)("li",{parentName:"ul"},"The unlock signature of the controller of the address that holds the native tokens melted.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const wsTsxEssence = new WriteStream();\nserializeTransactionEssence(wsTsxEssence, transactionEssence);\nconst essenceFinal = wsTsxEssence.finalBytes();\n\nconst essenceHash = Blake2b.sum256(essenceFinal);\n\nconst unlockSignature: ISignatureUnlock = {\n    type: SIGNATURE_UNLOCK_TYPE,\n    signature: {\n        type: ED25519_SIGNATURE_TYPE,\n        publicKey: stateControllerPubKey,\n        signature: Converter.bytesToHex(Ed25519.sign(Converter.hexToBytes(stateControllerPrivateKey), essenceHash), true)\n    }\n};\n\nconst unlockFoundry: IAliasUnlock = {\n    type: ALIAS_UNLOCK_TYPE,\n    reference: 0\n};\n\nconst unlockTokens: ISignatureUnlock = {\n    type: SIGNATURE_UNLOCK_TYPE,\n    signature: {\n        type: ED25519_SIGNATURE_TYPE,\n        publicKey: nativeTokenOwnerPubKey,\n        signature: Converter.bytesToHex(Ed25519.sign(Converter.hexToBytes(nativeTokenOwnerPrivateKey), essenceHash), true)\n    }\n};\n\nconst transactionPayload: ITransactionPayload = {\n    type: TRANSACTION_PAYLOAD_TYPE,\n    essence: transactionEssence,\n    unlocks: [unlockSignature, unlockFoundry, unlockTokens]\n};\n")),(0,a.kt)("h2",{id:"submit-the-blockb"},"Submit the blockB"),(0,a.kt)("p",null,"And finally, you can submit the block. After the block is confirmed, you can query the ",(0,a.kt)("a",{parentName:"p",href:"https://explorer.shimmer.network/"},"Shimmer Explorer")," for your Alias Address and find the new Alias Output with the updated state."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'const block: IBlock = {\n    protocolVersion: DEFAULT_PROTOCOL_VERSION,\n    parents: [],\n    payload: transactionPayload,\n    nonce: "0",\n};\n\nconst blockId = await client.blockSubmit(block);\nconsole.log("Block Id:", blockId);\n')),(0,a.kt)("h2",{id:"putting-it-all-together"},"Putting It All Together"),(0,a.kt)("p",null,"You can download the code to melt native tokens from the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/iotaledger/iota.js/tree/feat/stardust/packages/iota/examples/shimmer-native-token-transaction-tutorial/src/melt-tokens.ts"},"iota.js repository"),"."))}d.isMDXComponent=!0}}]);