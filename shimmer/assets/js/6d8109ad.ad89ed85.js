"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[77307],{3905:(t,e,n)=>{n.d(e,{Zo:()=>p,kt:()=>h});var a=n(67294);function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function s(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach((function(e){o(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function r(t,e){if(null==t)return{};var n,a,o=function(t,e){if(null==t)return{};var n,a,o={},i=Object.keys(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||(o[n]=t[n]);return o}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(o[n]=t[n])}return o}var l=a.createContext({}),u=function(t){var e=a.useContext(l),n=e;return t&&(n="function"==typeof t?t(e):s(s({},e),t)),n},p=function(t){var e=u(t.components);return a.createElement(l.Provider,{value:e},t.children)},d={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},c=a.forwardRef((function(t,e){var n=t.components,o=t.mdxType,i=t.originalType,l=t.parentName,p=r(t,["components","mdxType","originalType","parentName"]),c=u(n),h=o,m=c["".concat(l,".").concat(h)]||c[h]||d[h]||i;return n?a.createElement(m,s(s({ref:e},p),{},{components:n})):a.createElement(m,s({ref:e},p))}));function h(t,e){var n=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var i=n.length,s=new Array(i);s[0]=c;var r={};for(var l in e)hasOwnProperty.call(e,l)&&(r[l]=e[l]);r.originalType=t,r.mdxType="string"==typeof t?t:o,s[1]=r;for(var u=2;u<i;u++)s[u]=n[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},14428:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>u});var a=n(87462),o=(n(67294),n(3905));const i={description:"Mint native tokens with iota.js.",image:"/img/client_banner.png",keywords:["tutorial","alias","address","output","mint","foundry","native token","token","digital","asset"]},s="Mint Native Tokens",r={unversionedId:"tutorials/native-token-transactions/mint-native-tokens",id:"tutorials/native-token-transactions/mint-native-tokens",title:"Mint Native Tokens",description:"Mint native tokens with iota.js.",source:"@site/shimmer/external/iota.js/documentation/docs/tutorials/native-token-transactions/03-mint-native-tokens.md",sourceDirName:"tutorials/native-token-transactions",slug:"/tutorials/native-token-transactions/mint-native-tokens",permalink:"/shimmer/iotajs/tutorials/native-token-transactions/mint-native-tokens",draft:!1,editUrl:"https://github.com/iotaledger/iota.js/tree/feat/stardust/documentation/shimmer/external/iota.js/documentation/docs/tutorials/native-token-transactions/03-mint-native-tokens.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{description:"Mint native tokens with iota.js.",image:"/img/client_banner.png",keywords:["tutorial","alias","address","output","mint","foundry","native token","token","digital","asset"]},sidebar:"docs",previous:{title:"Prepare Your Development Environment",permalink:"/shimmer/iotajs/tutorials/native-token-transactions/prepare-the-dev-env"},next:{title:"Send Native Tokens",permalink:"/shimmer/iotajs/tutorials/native-token-transactions/native-tokens-transaction"}},l={},u=[{value:"Transfer Funds to Cover Storage Deposits",id:"transfer-funds-to-cover-storage-deposits",level:2},{value:"Mint a New Alias ID",id:"mint-a-new-alias-id",level:2},{value:"Prepare the Alias Address",id:"prepare-the-alias-address",level:2},{value:"Obtain the Current Alias Output",id:"obtain-the-current-alias-output",level:3},{value:"Define the Next Alias Output (transition)",id:"define-the-next-alias-output-transition",level:3},{value:"Define your Token Scheme",id:"define-your-token-scheme",level:2},{value:"Define the Foundry Output",id:"define-the-foundry-output",level:2},{value:"Create the Token Class ID",id:"create-the-token-class-id",level:3},{value:"Define the Basic Output That Will Hold the Initial Batch of Minted Tokens",id:"define-the-basic-output-that-will-hold-the-initial-batch-of-minted-tokens",level:2},{value:"Calculate and Set the Storage Deposits",id:"calculate-and-set-the-storage-deposits",level:2},{value:"Submit the Transaction",id:"submit-the-transaction",level:2},{value:"Create the Transaction Essence",id:"create-the-transaction-essence",level:3},{value:"Provide the Transaction Signature",id:"provide-the-transaction-signature",level:3},{value:"Submit the Block",id:"submit-the-block",level:3},{value:"Putting It All Together",id:"putting-it-all-together",level:2}],p={toc:u};function d(t){let{components:e,...n}=t;return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"mint-native-tokens"},"Mint Native Tokens"),(0,o.kt)("p",null,"To mint a new native token you will need the following:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"An initial ",(0,o.kt)("em",{parentName:"li"},"unspent Output")," with enough funds to cover the ",(0,o.kt)("a",{parentName:"li",href:"https://wiki.iota.org/shimmer/introduction/explanations/what_is_stardust/storage_deposit/"},"storage costs")," of the different Outputs involved. In the Testnet, you can ",(0,o.kt)("a",{parentName:"li",href:"../value-transactions/request-funds-from-the-faucet/"},"request funds through the Faucet"),".")),(0,o.kt)("admonition",{title:"Storage Deposits",type:"info"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("a",{parentName:"p",href:"https://wiki.iota.org/shimmer/learn/role-of-token/#storage-deposits"},"Storage deposits")," can only be covered by ",(0,o.kt)("strong",{parentName:"p"},"protocol-defined tokens")," (",(0,o.kt)("inlineCode",{parentName:"p"},"SMR"),").")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"An ",(0,o.kt)("em",{parentName:"p"},"Alias Address")," that you will use to control the Foundry Output associated with your new native tokens. Any change made to the Foundry state will require the keys of the ",(0,o.kt)("a",{parentName:"p",href:"https://wiki.iota.org/shimmer/tips/tips/TIP-0018/#state-controller-address-unlock-condition"},"State Controller")," of this Alias Address and the corresponding state transition that will generate an unspent Alias Output.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"A ",(0,o.kt)("em",{parentName:"p"},"Token Scheme")," that defines a class of tokens with ",(0,o.kt)("em",{parentName:"p"},"initial supply")," (how many native tokens of that class you will mint initially) and ",(0,o.kt)("em",{parentName:"p"},"maximum supply"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"A ",(0,o.kt)("em",{parentName:"p"},"Foundry Output")," that captures all the parameters and the state related to your new native tokens, including the ",(0,o.kt)("a",{parentName:"p",href:"https://wiki.iota.org/shimmer/tips/tips/TIP-0018/#simple-token-scheme-validation-rules"},"Token Scheme"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"An ",(0,o.kt)("em",{parentName:"p"},"Address")," to which you will transfer the initial supply of native tokens through a Basic Output. You can find a guide to generating your ",(0,o.kt)("a",{parentName:"p",href:"/shimmer/iotajs/tutorials/value-transactions/generate-a-seed"},"seed")," and ",(0,o.kt)("a",{parentName:"p",href:"/shimmer/iotajs/tutorials/value-transactions/generate-addresses"},"address")," in the ",(0,o.kt)("a",{parentName:"p",href:"/shimmer/iotajs/tutorials/value-transactions/introduction"},"send value transactions tutorial"),"."))),(0,o.kt)("h2",{id:"transfer-funds-to-cover-storage-deposits"},"Transfer Funds to Cover Storage Deposits"),(0,o.kt)("p",null,"The first step is to ensure that you have enough funds in your initial address to cover storage deposits. In the Testnet, you can simply ",(0,o.kt)("a",{parentName:"p",href:"/shimmer/iotajs/tutorials/value-transactions/request-funds-from-the-faucet"},"request funds from the Faucet")," to your address."),(0,o.kt)("h2",{id:"mint-a-new-alias-id"},"Mint a New Alias ID"),(0,o.kt)("p",null,"You can find information on ",(0,o.kt)("a",{parentName:"p",href:"/shimmer/iotajs/tutorials/alias-transactions/mint-new-alias"},"minting a new Alias address")," in the ",(0,o.kt)("a",{parentName:"p",href:"/shimmer/iotajs/tutorials/alias-transactions/introduction"},"Alias transactions tutorial"),".  Please ensure that you transfer enough funds to this Alias so that it can cover later costs related to minting native tokens."),(0,o.kt)("p",null,"This tutorial uses the following Alias:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Alias Address: ",(0,o.kt)("inlineCode",{parentName:"li"},"rms1pzxgrrzzug2rhaug8d0tgcq33p2g65s4x4h8c9ym6nxkmaj3r5zeg5fxxa7")),(0,o.kt)("li",{parentName:"ul"},"Alias ID: ",(0,o.kt)("inlineCode",{parentName:"li"},"0x8c818c42e2143bf7883b5eb4601188548d5215356e7c149bd4cd6df6511d0594")),(0,o.kt)("li",{parentName:"ul"},"State Controller Address: ",(0,o.kt)("inlineCode",{parentName:"li"},"rms1qpj8775lmqcudesrfel9f949ptk30mma9twjqza5el08vjww9v927ywt70u"))),(0,o.kt)("admonition",{title:"Storage Deposits",type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"This tutorial assumes that the newly minted Alias ID holds enough funds (protocol-defined tokens, or ",(0,o.kt)("inlineCode",{parentName:"p"},"SMR"),") to cover the new Outputs that you will generate.")),(0,o.kt)("h2",{id:"prepare-the-alias-address"},"Prepare the Alias Address"),(0,o.kt)("h3",{id:"obtain-the-current-alias-output"},"Obtain the Current Alias Output"),(0,o.kt)("p",null,"Once you have your Alias ID, you will need to get its current unspent Alias Output through the ",(0,o.kt)("a",{parentName:"p",href:"https://wiki.iota.org/shimmer/inx-indexer/welcome/"},"Indexer Plugin"),". The Alias Output will participate in a transaction that will create a new Foundry Output and mint native tokens."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'const aliasId = "0x8c81...";\nconst client = new SingleNodeClient(API_ENDPOINT, { powProvider: new NeonPowProvider() });\n\nconst indexerPlugin = new IndexerPluginClient(client);\nconst outputList = await indexerPlugin.alias(aliasId);\nconst consumedOutputId = outputList.items[0];\n\nconst initialAliasOutputDetails = await client.output(consumedOutputId);\nconst initialAliasOutput: IAliasOutput = initialAliasOutputDetails.output as IAliasOutput;\n')),(0,o.kt)("h3",{id:"define-the-next-alias-output-transition"},"Define the Next Alias Output (transition)"),(0,o.kt)("p",null,"To define the next Alias Output, you need to trigger a transition of the UTXO machine associated to your Alias ID. To do so, you will need to define a new Alias Output. The new Alias Output will increment the ",(0,o.kt)("inlineCode",{parentName:"p"},"stateIndex"),". Since you associate your Alias ID with a new Foundry that will control your new native token class, you must set the ",(0,o.kt)("inlineCode",{parentName:"p"},"foundryCounter")," field to ",(0,o.kt)("inlineCode",{parentName:"p"},"1"),"."),(0,o.kt)("p",null,"In the code below you can observe that the amount associated to the new Alias Output is set to ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),". That's because, initially, you don\u2019t know how many funds will remain on the next Alias Output. What it is sure is that the amount of funds remaining will be less than in the initial Output, as you will be using some of those funds to cover the storage deposit of the new Outputs that will be generated during this process. Alternatively, you could have involved other Outputs in this transaction to cover those storage costs.."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'const nextAliasOutput: IAliasOutput = JSON.parse(JSON.stringify(initialAliasOutput));\nnextAliasOutput.stateIndex++;\nnextAliasOutput.aliasId = aliasId;\nnextAliasOutput.amount = "0";\nnextAliasOutput.foundryCounter = 1;\n')),(0,o.kt)("h2",{id:"define-your-token-scheme"},"Define your Token Scheme"),(0,o.kt)("p",null,"You can define your Token Scheme as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const mintedAmount = 128;\nconst totalAmount = 512;\nconst tokenScheme: ISimpleTokenScheme = {\n    type: SIMPLE_TOKEN_SCHEME_TYPE,\n    mintedTokens: HexHelper.fromBigInt256(bigInt(mintedAmount)),\n    meltedTokens: HexHelper.fromBigInt256(bigInt(0)),\n    maximumSupply: HexHelper.fromBigInt256(bigInt(totalAmount)),\n};\n")),(0,o.kt)("p",null,"You can observe that you need to define the total amount and the maximum supply of minted tokens."),(0,o.kt)("h2",{id:"define-the-foundry-output"},"Define the Foundry Output"),(0,o.kt)("p",null,"Your next step is to define the Foundry Output (",(0,o.kt)("inlineCode",{parentName:"p"},"IFoundryOutput"),") that will control your new Token Scheme. You will need to set the serial number of the Foundry (",(0,o.kt)("inlineCode",{parentName:"p"},"1")," in this case), the formerly defined token scheme and the ",(0,o.kt)("a",{parentName:"p",href:"https://wiki.iota.org/shimmer/introduction/explanations/what_is_stardust/unlock_conditions/"},"unlock conditions"),". The Foundry Output can only be unlocked by the state controller of the Alias Address that controls it."),(0,o.kt)("p",null,"As with the Alias Output, you need to deliberately set the amount to ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),", as at this point in time you don't know the amount of protocol-defined tokens you will need to cover the storage deposit for this Output."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'const foundryOutput: IFoundryOutput = {\n    type: FOUNDRY_OUTPUT_TYPE,\n    amount: "0", // Not known yet\n    serialNumber: 1,\n    tokenScheme,\n    unlockConditions: [\n        {\n            // Foundry supports only this unlock condition!\n            // It will be controlled through its lifetime by our alias\n            type: IMMUTABLE_ALIAS_UNLOCK_CONDITION_TYPE,\n            address: {\n                type: ALIAS_ADDRESS_TYPE,\n                aliasId\n            }\n        }\n    ]\n};\n')),(0,o.kt)("h3",{id:"create-the-token-class-id"},"Create the Token Class ID"),(0,o.kt)("p",null,"To issue native token transactions,  you will need a way to refer to each class of native tokens controlled by each foundry uniquely. You can do it using the class ID, which you can obtain by calculating a hash of the Alias ID, foundry serial output, and the type of token scheme as shown in the following snippet:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const tokenClassId: string = TransactionHelper.constructTokenId(\n    nextAliasOutput.aliasId,\n    foundryOutput.serialNumber,\n    foundryOutput.tokenScheme.type\n);\n")),(0,o.kt)("p",null,"If you use this tutorial\u2019s Alias ID, you should obtain the following token class ID:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"0x080e6284ef54774f66942ef48f0c98c6da6e5b4e3ed044e83bd8da43f5b01790cb0100000000"),"."),(0,o.kt)("p",null,"That token class ID is simply the Foundry ID that will remain immutable regardless of the state changes of your Foundry."),(0,o.kt)("h2",{id:"define-the-basic-output-that-will-hold-the-initial-batch-of-minted-tokens"},"Define the Basic Output That Will Hold the Initial Batch of Minted Tokens"),(0,o.kt)("p",null,"As the Foundry has an initial set of minted tokens, you will need a ",(0,o.kt)("a",{parentName:"p",href:"https://wiki.iota.org/shimmer/introduction/explanations/ledger/simple_transfers/"},"Basic Output")," to hold those native tokens. This new Basic Output will hold the initial amount of minted native tokens identified through their token class ID. As with other Outputs, you need to set the amount of protocol-defined tokens to ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," as you don't know yet the storage deposit cost."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'const nativeTokenOwnerAddress = "0x647f....";\n\nconst tokenFundsOutput: IBasicOutput = {\n    type: BASIC_OUTPUT_TYPE,\n    amount: "0", // Not known yet\n    nativeTokens: [\n        // We put all minted tokens in this output\n        {\n            id: tokenClassId,\n            amount: HexHelper.fromBigInt256(bigInt(mintedAmount))\n        }\n    ],\n    unlockConditions: [\n        {\n            type: ADDRESS_UNLOCK_CONDITION_TYPE,\n            address: {\n                type: ED25519_ADDRESS_TYPE,\n                pubKeyHash: nativeTokenOwnerAddress\n            }\n        }\n    ]\n};\n')),(0,o.kt)("h2",{id:"calculate-and-set-the-storage-deposits"},"Calculate and Set the Storage Deposits"),(0,o.kt)("p",null,"Next, you should calculate the storage deposit that will be needed for each Output. A helper function provided by ",(0,o.kt)("inlineCode",{parentName:"p"},"iota.js")," will allow you to determine the exact number of protocol-defined tokens needed for each Output. This helper function needs the protocol parameters to be exposed by the Node, using the ",(0,o.kt)("a",{parentName:"p",href:"../../references/client/interfaces/IClient/#info"},(0,o.kt)("inlineCode",{parentName:"a"},"client.info()")," function"),"."),(0,o.kt)("p",null,"The next Alias Output of the Alias Address will hold fewer funds than the original, as those funds will be used to cover the storage deposits of the Foundry Output and the Basic Output that will hold the minted native token funds."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'const nodeInfo = await client.info();\n\nconst foundryStorageDeposit = TransactionHelper.getStorageDeposit(foundryOutput, nodeInfo.protocol.rentStructure);\nconst tokenFundsStorageDeposit = TransactionHelper.getStorageDeposit(tokenFundsOutput, nodeInfo.protocol.rentStructure);\n\nconst totalStorageFunds = bigInt(foundryStorageDeposit).plus(bigInt(tokenFundsStorageDeposit));\n\nconst initialFunds = bigInt(initialAliasOutput.amount);\nif (initialFunds.lesser(totalStorageFunds)) {\n    throw new Error("Initial funds not enough to cover for storage deposits");\n}\n\nnextAliasOutput.amount = initialFunds.minus(totalStorageFunds).toString();\nfoundryOutput.amount = foundryStorageDeposit.toString();\ntokenFundsOutput.amount = tokenFundsStorageDeposit.toString();\n')),(0,o.kt)("h2",{id:"submit-the-transaction"},"Submit the Transaction"),(0,o.kt)("h3",{id:"create-the-transaction-essence"},"Create the Transaction Essence"),(0,o.kt)("p",null,"This is a complex transaction that involves one input and three different outputs. The input is the Alias Output you obtained through your initial query to the indexer plugin. The Outputs are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The next Alias Output of your Alias Address (",(0,o.kt)("inlineCode",{parentName:"li"},"nextAliasOutput"),")."),(0,o.kt)("li",{parentName:"ul"},"The initial Foundry Output (",(0,o.kt)("inlineCode",{parentName:"li"},"foundryOutput"),")."),(0,o.kt)("li",{parentName:"ul"},"The Basic Output that holds the native token funds initially minted (",(0,o.kt)("inlineCode",{parentName:"li"},"tokenFundsOutput"),").")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const inputs: IUTXOInput[] = [];\nconst outputs: (IAliasOutput | IFoundryOutput | IBasicOutput)[] = [];\n\ninputs.push(TransactionHelper.inputFromOutputId(consumedOutputId));\noutputs.push(nextAliasOutput);\noutputs.push(foundryOutput);\noutputs.push(tokenFundsOutput);\n\nconst inputsCommitment = TransactionHelper.getInputsCommitment([initialAliasOutput]);\nconst transactionEssence: ITransactionEssence = {\n    type: TRANSACTION_ESSENCE_TYPE,\n    networkId: TransactionHelper.networkIdFromNetworkName(nodeInfo.protocol.networkName),\n    inputs,\n    inputsCommitment,\n    outputs\n};\n\nconst wsTsxEssence = new WriteStream();\nserializeTransactionEssence(wsTsxEssence, transactionEssence);\nconst essenceFinal = wsTsxEssence.finalBytes();\nconst essenceHash = Blake2b.sum256(essenceFinal);\n")),(0,o.kt)("h3",{id:"provide-the-transaction-signature"},"Provide the Transaction Signature"),(0,o.kt)("p",null,"Once you have the ",(0,o.kt)("a",{parentName:"p",href:"#create-the-transaction-essence"},"created the transaction essence"),", you need to provide the signature that unlocks your ",(0,o.kt)("a",{parentName:"p",href:"#obtain-the-current-alias-output"},"initial Alias Output"),", the Input of the transaction. Remember that unlocking an Alias Output requires the Private Key of the State Controller Address."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'const stateControllerPubKey = "0x55419...";\nconst stateControllerPrivateKey = "0xa060f....";\n\nconst unlockSignature: ISignatureUnlock = {\n    type: SIGNATURE_UNLOCK_TYPE,\n    signature: {\n        type: ED25519_SIGNATURE_TYPE,\n        publicKey: stateControllerPubKey,\n        signature: Converter.bytesToHex(Ed25519.sign(Converter.hexToBytes(stateControllerPrivateKey), essenceHash), true)\n    }\n};\n\nconst transactionPayload: ITransactionPayload = {\n    type: TRANSACTION_PAYLOAD_TYPE,\n    essence: transactionEssence,\n    unlocks: [unlockCondition]\n};\n')),(0,o.kt)("h3",{id:"submit-the-block"},"Submit the Block"),(0,o.kt)("p",null,"Now that you have the transaction payload, you can submit the ",(0,o.kt)("a",{parentName:"p",href:"/shimmer/iotajs/references/client/interfaces/IBlock"},"Block"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'const block: IBlock = {\n    protocolVersion: DEFAULT_PROTOCOL_VERSION,\n    parents: [],\n    payload: transactionPayload,\n    nonce: "0",\n};\n\nconst blockId = await client.blockSubmit(block);\nconsole.log("Block ID:", blockId);\nconsole.log("Native Token Class ID", tokenClassId);\n')),(0,o.kt)("p",null,"Once you know the Block ID and the Native Token Class ID, you can query them through the ",(0,o.kt)("a",{parentName:"p",href:"https://explorer.shimmer.network/"},"Shimmer Explorer")," to verify that your transaction went well and the Foundry Output has been added to the Ledger."),(0,o.kt)("h2",{id:"putting-it-all-together"},"Putting It All Together"),(0,o.kt)("p",null,"You can download the code to mint a native token from the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/iotaledger/iota.js/tree/feat/stardust/packages/iota/examples/shimmer-native-token-transaction-tutorial/src/mint-tokens.ts"},"iota.js repository"),"."))}d.isMDXComponent=!0}}]);